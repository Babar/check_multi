#!/usr/bin/perl -w
#
# check_multi - nagios plugin
#
# Copyright (c) 2007 Matthias Flacke (matthias.flacke at gmx.de)
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#
#
# $Id$
#
#nagios: -epn
#
# TODO:
# - handling of undefined RC
# - customizeable return code handling
# - libexec: configure script
# - verbose output
#
use strict;
use Getopt::Long qw(:config no_ignore_case bundling);
BEGIN { eval("use Time::HiRes qw(time)") }
use lib "/usr/local/nagios/libexec";
use vars qw(
$MYSELF %cmds $returncode %rc $no $VERSION
$OK $WARNING $CRITICAL $UNKNOWN
$DETAIL_LIST $DETAIL_LIST_FULL $DETAIL_HTML $DETAIL_STDERR $DETAIL_PERFORMANCE
$DETAIL_PERFORMANCE_CLASSIC $DETAIL_COMMAND_LIST $DETAIL_PNP_LINK $DETAIL_XML
$DETAIL_NAGIOS2
);
#-------------------------------------------------------------------------------
#--- vars ----------------------------------------------------------------------
#-------------------------------------------------------------------------------
$MYSELF="check_multi";
$VERSION='$Revision$ $Date$ $Author$';
#
#--- RC defines
$OK=0;
$WARNING=1;
$CRITICAL=2;
$UNKNOWN=3;
#
#--- report defines
$DETAIL_LIST=1;
$DETAIL_HTML=2;
$DETAIL_STDERR=4;
$DETAIL_PERFORMANCE=8;
$DETAIL_LIST_FULL=16;
$DETAIL_PERFORMANCE_CLASSIC=32;
$DETAIL_COMMAND_LIST=64;
$DETAIL_PNP_LINK=128;
$DETAIL_XML=256;
$DETAIL_NAGIOS2=512;
#
#--- vars
$no=0;
%cmds=();
$returncode=0;
%rc=(
	label	=> { $OK => "OK", $WARNING => "WARNING", $CRITICAL => "CRITICAL", $UNKNOWN => "UNKNOWN", },
	charind => "owcu",
	s2r	=> { 0 => $OK, 2 => $WARNING, 3 => $CRITICAL, 1 => $UNKNOWN, },
	r2s	=> { $OK => 0, $WARNING => 2, $CRITICAL => 3, $UNKNOWN => 1, },
	count	=> { $OK => 0, $WARNING => 0, $CRITICAL => 0, $UNKNOWN => 0, },
	list	=> { $OK => [],$WARNING => [],$CRITICAL => [],$UNKNOWN => [], },
	range	=> { $OK => {},$WARNING => {},$CRITICAL => {},$UNKNOWN => {}, },
	top	=> $OK,
	error	=> [ ],
	starttime => 0.0,
	endtime => 0.0,
	runtime => 0.0,
	nchecks => 0,
);

my %opt=(
	"configfile"	=> "",
	"libexec"	=> "/usr/local/nagios/libexec",
	"name"		=> "MULTI",
	"report"	=> 13,
	"state"		=> undef,
	"timeout"	=> 10,
	"TIMEOUT"	=> 60,
	"ok"		=> "\@1:",
	"warning"	=> "\@1:",
	"critical"	=> "\@1:",
	"unknown"	=> "\@1:",
);
	
#-------------------------------------------------------------------------------
#--- subs ----------------------------------------------------------------------
#-------------------------------------------------------------------------------

sub process_parameters {

	if (! GetOptions(
		"f|filename=s"	=> \$opt{filename},
		"h|help"	=> \$opt{help},
		"l|libexec=s"	=> \$opt{libexec},
		"n|name=s"	=> \$opt{name},
		"r|report:i"	=> \$opt{report},
		"t|timeout=i"	=> \$opt{timeout},
		"T|TIMEOUT=i"	=> \$opt{TIMEOUT},
		"V|version"	=> \$opt{version},

		"s|state=s"	=> \$opt{state},
		"o|ok=s"	=> \$opt{ok},
		"w|warning=s"	=> \$opt{warning},
		"c|critical=s"	=> \$opt{critical},
		"u|unknown=s"	=> \$opt{unknown},)
	) {
		short_usage();
        	return $UNKNOWN;
	}

	if ($opt{version}) {
		print "$MYSELF: v$VERSION\n";
        	return $UNKNOWN;
	}

	if ($opt{help}) {
		short_usage();
        	long_usage();
        	return $UNKNOWN;
	}

	if (! $opt{filename}) {
        	print "$MYSELF error: no config file specified\n";
		short_usage();
        	return $UNKNOWN;
	}
	if ($opt{warning}) {
		parse_range_string(\%{$rc{range}{$WARNING}},$opt{warning});
	}
	if ($opt{critical}) {
		parse_range_string(\%{$rc{range}{$CRITICAL}},$opt{critical});
	}
	if ($opt{unknown}) {
		parse_range_string(\%{$rc{range}{$UNKNOWN}},$opt{unknown});
	}
	if ($opt{ok}) {
		parse_range_string(\%{$rc{range}{$OK}},$opt{ok});
	}
	if ($opt{state}) {
		if (defined($rc{label}{$opt{state}})) {
			# already numerical: ok
		} elsif ($opt{state}=~/[owcu]?/i) {
			$opt{state}=lc($opt{state});
			$opt{state}=index("owcu",$opt{state});
		} else {
			print "$MYSELF error: invalid state defined\n";
			short_usage();
			return $UNKNOWN;
		}
	}
	if ($opt{timeout} && $opt{TIMEOUT} && $opt{timeout} >= $opt{TIMEOUT}) {
		print "$MYSELF: error - child timeout $opt{timeout}s >= parent timeout $opt{TIMEOUT}s\n";
		return $UNKNOWN;
	}
	return $OK;
}

sub short_usage {
print <<SHORTEOF;
$MYSELF -f <config file> [-l libexec_path] [-n name] [-t timeout] [-T TIMEOUT] [-r level]
        [-s state] [-w N:N] [-c N:N] [-u N:N] [-o N:N]
$MYSELF [-h | --help]
$MYSELF [-V | --version]

SHORTEOF
}

sub long_usage {
print <<LONGEOF;
Options:
-f, --filename
   config file which contains commands to be executed
   (file format follows nrpe style: command[tag]=plugin command line)
-l, --libexec
   path to plugins, default: $opt{libexec}
-n, --name
   multi plugin name (shown in output), default: $opt{name}
-t, --timeout
   timeout for one command, default: $opt{timeout}
-T, --TIMEOUT
   TIMEOUT for all commands, default: $opt{TIMEOUT}
-r, --report <level>
   specify level of details in output (level is binary coded, just add all options)
   default: $opt{report}
      1: mention service names in plugin_output, e.g.
         "24 plugins checked, 1 critical (http), 0 warning, 0 unknown, 23 ok"
      2: add HTML coloring of output for extinfo
      4: show STDERR (if any) in each line of plugin output
      8: show performance data (with check_multi_style)
      16: show full list of states, normally '0 warning' is omitted
      32: show old type of performance data (without check_multi style)
      64: show list of commands in output
      128: add PNP action link if performance data available
      256: XML: print structured XML output
      512: Nagios 2: one line output
-h, --help
   print detailed help screen
-V, --version
   print version information

Extended mode - specify extra settings for threshold interpretation:
-w, --warning  <minimum:maximum>
-c, --critical <minimum:maximum>
-u, --unknown  <minimum:maximum>
-o, --ok       <minimum:maximum>
-s, --state    
   wanted overall state, allowed is: 'o','w','c','u', 0-3
  default: highest severity
LONGEOF

}

#---
#--- numerical sort
#---
sub numerically { $a <=> $b }

#---
#--- trim input string if found any chars from trim string
#---
sub mytrim {
	my ($src, $trim)=@_;
	return ($src=~/[$trim]*(.*)[$trim]*/) ? $1 : $src;
}

#---
#--- substitute macros a la $HOSTNAME$ from environment
#---
sub substitute_macros {
        my ($input)=@_;
        while ((my $var)=($input=~/\$([A-Z0-9^\$]+)\$/)) {
		last if (!defined($ENV{"NAGIOS_$var"}));
                $input=~s/\$$var\$/$ENV{"NAGIOS_$var"}/g;
        }
        return $input;
}

#---
#--- add error(s) to global error list
#---
sub add_error {
	push @{$rc{error}}, @_;
}

# The next two routines have been taken and adopted from Nagios::Plugin.
# Thanks to Gavin Carr and Ton Voon! 
# Some day I'll find time to migrate the whole stuff to Nagios::Plugin ;-)
sub parse_range_string {
        my ($range, $string) = @_;
        my $valid = 0;

        $range->{start}=0;
	$range->{start_infinity}=0;
	$range->{end}=0;
	$range->{end_infinity}=1;
	$range->{inside}=0;

        $string =~ s/\s//g;  # strip out any whitespace
        # check for valid range definition
        unless ( $string =~ /[\d~]/ && $string =~ m/^\@?(-?[\d.]+|~)?(:(-?[\d.]+)?)?$/ ) {
		print "Invalid range definition '$string'\n";
		return undef;
        }

        if ($string =~ s/^\@//) {
		$range->{inside}=1;
        }

        if ($string =~ s/^~//) {  # '~:x'
		$range->{start_infinity}=1;
        }
        if ( $string =~ m/^([\d\.-]+)?:/ ) {     # '10:'
		my $start = $1;
		if (defined($start)) {
			$range->{start}=$start;
			$range->{start_infinity}=0;
		}
            	$range->{end_infinity}=1;  # overridden below if there's an end specified
            	$string =~ s/^([-\d\.]+)?://;
            	$valid++;
        }
        if ($string =~ /^([-\d\.]+)$/) {   # 'x:10' or '10'
		$range->{end}=$string;
		$range->{end_infinity}=0;
		$valid++;
        }

        if ($valid && ($range->{start_infinity} == 1 || $range->{end_infinity} == 1 || $range->{start} <= $range->{end})) {
                return $range;
        }
        return undef;
}
# Returns 1 if an alert should be raised, otherwise 0
sub check_range {
        my ($range, $value) = @_;
        my $false = 0;
        my $true = 1;
        if ($range->{inside}) {
                $false = 1;
                $true = 0;
        }
        if ($range->{end_infinity} == 0 && $range->{start_infinity} == 0) {
                if ($range->{start} <= $value && $value <= $range->{end}) {
                        return $false;
                } else {
                        return $true;
                }
        } elsif ($range->{start_infinity} == 0 && $range->{end_infinity} == 1) {
                if ( $value >= $range->{start} ) {
                        return $false;
                } else {
                        return $true;
                }
        } elsif ($range->{start_infinity} == 1 && $range->{end_infinity} == 0) {
                if ($value <= $range->{end}) {
                        return $false;
                } else {
                        return $true;
                }
        } else {
                return $false;
        }
}
#---
#--- create unique tmpfile and try to create it
#---
sub get_tmpfile {
	my ($path,$prefix)=@_;
	my $attempt=0;
	my $tmpfile="";
	#--- check existance of path and create it if necessary
	if (! -d $path && ! mkdir($path,0700)) {
		add_error("get_tmpfile: error creating tmp_path $path:$!");
		return "";
	}
	#--- do 5 attempts to create tmpfile
	while ($attempt++ < 5) {
		my $suffix=int(rand(89999))+10000;
		$tmpfile="$path/$prefix.$suffix";
		next if (-f $tmpfile);
		if (open(TMP,">$tmpfile")) {
			close TMP;
			return $tmpfile;
		}
	}
	add_error("get_tmpfile: giving up opening $tmpfile after $attempt attempts:$!");
	return "";
}

#---
#--- read file and return its contents
#---
sub readfile {
	my ($filename)=@_;
	open(FILE,$filename) || add_error("readfile: error opening $filename:$!") && return "";
	my @lines=<FILE>;
	close(FILE);
	return join("", @lines);
}

#---
#--- parse command file and fill %cmds structure
#---
sub parse_commands {
	my ($filename)=@_;
	my $lineno=0;		# count sourcefile lines
	my $cmd_count=0;	# count stored commands
	my ($cmd,$name,$plugin);

	if (!open(FILE, $filename)) {
		add_error("parse_command: cannot open config file $filename: $!");
		$rc{top}=$UNKNOWN;
		return $cmd_count;
	}

	while (<FILE>) {
		$lineno++;		
		next if (/^\s*$/);	# skip empty lines
		next if (/^\s*#/);	# skip comments
	
		chop($cmd=$_);
		$cmd=substitute_macros($cmd);

		#--- format: 'command[ tag ] = plugin command line'
		if ($cmd=~/\s*command\s*\[\s*(\S+)\s*\]\s*=\s*(.*)\s*/i) {
			$name=$1;
			$cmd=$2;
			$plugin=(split(/\s+/,"$cmd"))[0];
		} else {
			add_error("parse_command: invalid format in line $lineno: $cmd");
			next;
		}

		#--- store vars into cmds structure
		$cmd="$opt{libexec}/$cmd" if ($plugin!~/\//);
		$cmds{++$cmd_count}{command}=$cmd;
		$cmds{$cmd_count}{plugin}=$plugin;
		$cmds{$cmd_count}{name}=$name;
		$cmds{$cmd_count}{rc}=$UNKNOWN;
	}
	close FILE;
	return $cmd_count;
}

#---
#--- execute command number $no from %cmds
#---
sub exec_command {
	my ($no)=@_;
	my $tmp_stdout="";
	my $tmp_stderr="";

	#--- execute command with alarm timer to catch timeouts
	$SIG{'ALRM'} = sub { die "timeout" };
	eval {
		alarm($opt{timeout});

		#--- prepare tmpfiles for stdout and stderr
		$tmp_stdout=&get_tmpfile("/tmp", "${MYSELF}_stdout_$$");
		$tmp_stderr=&get_tmpfile("/tmp", "${MYSELF}_stderr_$$");

		#--- execute command and store stdout/stderr/return code
		`$cmds{$no}{command} 1>$tmp_stdout 2>$tmp_stderr`;
		$cmds{$no}{rc}=$? >> 8;

		#--- store stdout/stderr and cleanup tmpfiles
		$cmds{$no}{output}=readfile($tmp_stdout);
		$cmds{$no}{stderr}=readfile($tmp_stderr);
		unlink $tmp_stdout, $tmp_stderr;

		#--- unknown return code? change it explicitly to UNKNOWN
		if (! defined($rc{r2s}{$cmds{$no}{rc}})) {
			$cmds{$no}{stderr}.=" RC was $cmds{$no}{rc}!";
			$cmds{$no}{rc}=$UNKNOWN;
		}
		
		#--- remove white chars from output
		#$cmds{$no}{output}=mytrim($cmds{$no}{output},"\\n\\s");
		$cmds{$no}{stderr}=mytrim($cmds{$no}{stderr},"\\n\\s");

		#--- split performance data from standard output
		if ($cmds{$no}{output}=~/\|/) {
			($cmds{$no}{output},$cmds{$no}{performance})=split(/\|/,$cmds{$no}{output});
			$cmds{$no}{performance}=mytrim($cmds{$no}{performance},"\\s");
		}

		alarm(0);
	};
	
	#--- any oddities during command execution?
	if ($@) {
		#--- timeout encountered: store status
		if ($@ =~ /timeout/) {
			$cmds{$no}{output}="UNKNOWN - $cmds{$no}{plugin} cancelled after timeout ($opt{timeout}s)";
			$cmds{$no}{rc}=$UNKNOWN;
			$cmds{$no}{output}.=readfile($tmp_stdout);
			$cmds{$no}{stderr}.=readfile($tmp_stderr);
		#--- catchall for unknown errors
		} else {
			alarm(0);
       			die "$MYSELF: unexpected exception encountered:$!";
		}
		unlink $tmp_stdout, $tmp_stderr;
	}
	return $cmds{$no}{rc};
}

#---
#--- calculate sums from %cmds and %rc
#---
sub do_result_rating {

	#--- measure runtime without reporting ;-)
	$rc{runtime}=time - $rc{starttime};
	$rc{nchecks}=scalar(keys(%cmds));

	#--- count return codes
	foreach $no (sort numerically keys %cmds) {

		$rc{count}{$cmds{$no}{rc}}++;	# count return codes
		push @{$rc{list}{$cmds{$no}{rc}}},$cmds{$no}{name}; # add plugin to list
		#print STDERR "DEBUG: rc:$cmds{$no}{rc} ok:$rc{count}{$OK} unknown:$rc{count}{$UNKNOWN} warning:$rc{count}{$WARNING} critical:$rc{count}{$CRITICAL}\n";

		#--- determine return code with highest severity
		#print STDERR "DEBUG: r2s-rc:$rc{r2s}{$cmds{$no}{rc}} top:$rc{r2s}{$rc{top}} rc:$cmds{$no}{rc}\n";
		#$rc{top}=$cmds{$no}{rc} if ($rc{r2s}{$cmds{$no}{rc}} > $rc{r2s}{$rc{top}});
	}
	
	foreach my $s (sort numerically keys %{$rc{s2r}}) {
		#print "Performing $rc{label}{$state}\n";
		#next if not defined($rc{range}{$state}{start});
		if (check_range(\%{$rc{range}{ $rc{s2r}{$s}  }},$rc{count}{ $rc{s2r}{$s}    })) {
			#print "$rc{label}{$state} matches\n";
			if (defined($opt{state})) {
				$rc{top}=$opt{state};
			} else {
				$rc{top}=$rc{s2r}{$s};
			}
		}
	}
}

#---
#--- report results stored in %cmds
#---
sub do_report {

	if ($opt{report} & $DETAIL_NAGIOS2) {
		print "$opt{name} $rc{label}{$rc{top}}";
	} else {
		#--- print header line (1): name, state, number of plugins
		print "$opt{name} $rc{label}{$rc{top}} - " . keys(%cmds) . " plugins checked, ";
	
		#--- print header line (2): summary for particular states 
		if ($opt{report} & $DETAIL_LIST_FULL) {
			print	"$rc{count}{$CRITICAL} critical" . ((@{$rc{list}{$CRITICAL}}) ? " (" . join(', ',@{$rc{list}{$CRITICAL}}) . ')' : "") . ", " .
				"$rc{count}{$WARNING} warning"   . ((@{$rc{list}{$WARNING}})  ? " (" . join(', ',@{$rc{list}{$WARNING}})  . ')' : "") . ", " .
				"$rc{count}{$UNKNOWN} unknown"   . ((@{$rc{list}{$UNKNOWN}})  ? " (" . join(', ',@{$rc{list}{$UNKNOWN}})  . ')' : "") . ", " .
				"$rc{count}{$OK} ok";
		} elsif ($opt{report} & $DETAIL_LIST) {
			my @r=();
			push @r, "$rc{count}{$CRITICAL} critical (" . join(', ',@{$rc{list}{$CRITICAL}}) . ")" if (@{$rc{list}{$CRITICAL}});
			push @r, "$rc{count}{$WARNING} warning ("   . join(', ',@{$rc{list}{$WARNING}})  . ")" if (@{$rc{list}{$WARNING}});
			push @r, "$rc{count}{$UNKNOWN} unknown ("   . join(', ',@{$rc{list}{$UNKNOWN}})  . ")" if (@{$rc{list}{$UNKNOWN}});
			push @r, "$rc{count}{$OK} ok" if (@{$rc{list}{$OK}});
			print join(", ", @r);
		} else {
			print	"$rc{count}{$CRITICAL} critical, " .
				"$rc{count}{$WARNING} warning, " .
				"$rc{count}{$UNKNOWN} unknown, " .
				"$rc{count}{$OK} ok";
		}
	}
	#--- print general errors if any occured
	print " [" . join(", ",@{$rc{error}}) . "]" if (defined($rc{error}[0]));
	
	#--- print custom range settings if necessary
	foreach my $s (sort numerically keys %{$rc{s2r}}) {
		if ($rc{range}{ $rc{s2r}{$s} } !~ /\@1:/) {
			# !!!TODO!!!
		}
	}

	#--- loop over commands: report particular results for long plugin output
	foreach $no (sort numerically keys %cmds) {

		#--- if NAGIOS2 output: skip $OK results
		if ($opt{report} & $DETAIL_NAGIOS2) {
			next if ($cmds{$no}{rc} == $OK);
			printf ", %s %s%s",
				$cmds{$no}{name},
				$cmds{$no}{output},
				(defined($cmds{$no}{stderr}) && $cmds{$no}{stderr} ne "" && $opt{report} & $DETAIL_STDERR) ?
			 	" [ STDERR: " . $cmds{$no}{stderr} . ']' : "";
		} else {
			printf "%s[%2.d] %s %s%s",
				($opt{report} & $DETAIL_NAGIOS2) ? ", " : "\n",
				$no,
				$cmds{$no}{name},
				$cmds{$no}{output},
				(defined($cmds{$no}{stderr}) && $cmds{$no}{stderr} ne "" && $opt{report} & $DETAIL_STDERR) ?
			 	" [ STDERR: " . $cmds{$no}{stderr} . ']' : "";
		}
	}

	#--- print list of commands
	if ($opt{report} & $DETAIL_COMMAND_LIST) {
		print "\nCommands executed:";
		foreach $no (sort numerically keys %cmds) {
			printf "\n[%2.d] %s", $no, $cmds{$no}{command};
		}
	}
}

sub do_report_html {
	#--- print header line (1): name, state, number of plugins
	print "$opt{name} $rc{label}{$rc{top}} - " . keys(%cmds) . " plugins checked, ";

	#--- print header line (2): summary for particular states 
	if ($opt{report} & $DETAIL_LIST_FULL) {
		print	"$rc{count}{$CRITICAL} critical" . ((@{$rc{list}{$CRITICAL}}) ? " (" . join(', ',@{$rc{list}{$CRITICAL}}) . ')' : "") . ", " .
			"$rc{count}{$WARNING} warning"   . ((@{$rc{list}{$WARNING}})  ? " (" . join(', ',@{$rc{list}{$WARNING}})  . ')' : "") . ", " .
			"$rc{count}{$UNKNOWN} unknown"   . ((@{$rc{list}{$UNKNOWN}})  ? " (" . join(', ',@{$rc{list}{$UNKNOWN}})  . ')' : "") . ", " .
			"$rc{count}{$OK} ok";
	} elsif ($opt{report} & $DETAIL_LIST) {
		my @r=();
		push @r, "$rc{count}{$CRITICAL} critical (" . join(', ',@{$rc{list}{$CRITICAL}}) . ")" if (@{$rc{list}{$CRITICAL}});
		push @r, "$rc{count}{$WARNING} warning ("   . join(', ',@{$rc{list}{$WARNING}})  . ")" if (@{$rc{list}{$WARNING}});
		push @r, "$rc{count}{$UNKNOWN} unknown ("   . join(', ',@{$rc{list}{$UNKNOWN}})  . ")" if (@{$rc{list}{$UNKNOWN}});
		push @r, "$rc{count}{$OK} ok" if (@{$rc{list}{$OK}});
		print join(", ", @r);
	} else {
		print	"$rc{count}{$CRITICAL} critical, " .
			"$rc{count}{$WARNING} warning, " .
			"$rc{count}{$UNKNOWN} unknown, " .
			"$rc{count}{$OK} ok";
	}
	print "\n";

	#--- print general errors if any occured
	print " [" . join(", ",@{$rc{error}}) . "]" if (defined($rc{error}[0]));
	
	#--- loop over commands: report particular results for long plugin output
	#print "<table style='border-left:1px; border-style:dotted border-right-style:none border-top-style:none border-bottom-style:none'>";
	print "<table style='border-left-width:1px; border-left-style:dotted' border-rigth-width:0px; >";
	foreach $no (sort numerically keys %cmds) {
		printf "<tr valign='top'><td nowrap>%s[%2.d]%s</td><td nowrap>%s</td><td>%s</td><td>%s</td><td>%s</td>%s</tr>",
			($opt{report} & $DETAIL_HTML) ? "<DIV CLASS=\'service$rc{label}{$cmds{$no}{rc}}\'>" : "",
			$no,
			($opt{report} & $DETAIL_HTML) ? "</DIV>" : "",
			($opt{report} & $DETAIL_PERFORMANCE && $opt{report} & $DETAIL_PNP_LINK && defined($cmds{$no}{performance})) ?
				"<A HREF='/nagios/pnp/index.php?host=$ENV{NAGIOS_HOSTNAME}&srv=$cmds{$no}{name}' TARGET='_self'><img src='/nagios/images/action.gif' width=20 height=20 border=0 align=top alt='Show PNP chart for $ENV{NAGIOS_HOSTNAME} / $cmds{$no}{plugin}'></A>" : "",
			$cmds{$no}{name},
			$cmds{$no}{output},
			(defined($cmds{$no}{stderr}) && $cmds{$no}{stderr} ne "" && $opt{report} & $DETAIL_STDERR) ?
			 " [ STDERR: " . $cmds{$no}{stderr} . ']' : "",
			($opt{report} & $DETAIL_COMMAND_LIST) ? "<td>$cmds{$no}{command}</td>" : "";
			
	}
	print "</table>";

}

sub do_report_xml {
	print "<!--\n" if ($opt{report} & $DETAIL_HTML);
	print "<xml>\n";
	print "<meta http-equiv=\"Content-Style-Type\" content=\"application/xml\">\n";
	print "<?xml version=\"1.0\"?>\n";
	print "<?xml-stylesheet type=\"text/xsl\" href=\"http://localhost/nagios/extinfo.xsl\"?>\n";
	print "<PARENT name=\"$opt{name}\" plugins=\"$rc{nchecks}\" time=\"$rc{runtime}\">\n";
	print "\t<output>";
	#--- print header line (2): summary for particular states 
        if ($opt{report} & $DETAIL_LIST_FULL) {
                print   "$rc{count}{$CRITICAL} critical" . ((@{$rc{list}{$CRITICAL}}) ? " (" . join(', ',@{$rc{list}{$CRITICAL}}) . ')' : "") . ", " .
                        "$rc{count}{$WARNING} warning"   . ((@{$rc{list}{$WARNING}})  ? " (" . join(', ',@{$rc{list}{$WARNING}})  . ')' : "") . ", " .
                        "$rc{count}{$UNKNOWN} unknown"   . ((@{$rc{list}{$UNKNOWN}})  ? " (" . join(', ',@{$rc{list}{$UNKNOWN}})  . ')' : "") . ", " .
                        "$rc{count}{$OK} ok";
        } elsif ($opt{report} & $DETAIL_LIST) {
                my @r=();
                push @r, "$rc{count}{$CRITICAL} critical (" . join(', ',@{$rc{list}{$CRITICAL}}) . ")" if (@{$rc{list}{$CRITICAL}});
                push @r, "$rc{count}{$WARNING} warning ("   . join(', ',@{$rc{list}{$WARNING}})  . ")" if (@{$rc{list}{$WARNING}});
                push @r, "$rc{count}{$UNKNOWN} unknown ("   . join(', ',@{$rc{list}{$UNKNOWN}})  . ")" if (@{$rc{list}{$UNKNOWN}});
                push @r, "$rc{count}{$OK} ok" if (@{$rc{list}{$OK}});
                print join(", ", @r);
        } else {
                print   "$rc{count}{$CRITICAL} critical, " .
                        "$rc{count}{$WARNING} warning, " .
                        "$rc{count}{$UNKNOWN} unknown, " .
                        "$rc{count}{$OK} ok";
        }
	print "</output>\n";
	print "<error>" . join(", ",@{$rc{error}}) . "</error>\n" if (defined($rc{error}[0]));

	foreach $no (sort numerically keys %cmds) {
		printf "\t<CHILD no=\"$no\">\n";
		foreach my $token ("name","rc","output","stderr","plugin","command","performance") {
			printf "\t\t<%s>%s</%s>\n",$token,$cmds{$no}{$token},$token if defined($cmds{$no}{$token});
		}
		printf "\t</CHILD>\n";
	}
	print "</PARENT>\n";
	print "</xml>\n";
	print "\n--> " if ($opt{report} & $DETAIL_HTML);
}

sub do_report_perfdata {
	#--- report performance data?
	if ($opt{report} & $DETAIL_PERFORMANCE) {
		printf "\|$opt{name}::${MYSELF}::plugins=%d time=%.2f ", scalar(keys(%cmds)), time - $rc{starttime};
		#--- one line per command, format: tag=output
		foreach $no (sort numerically keys %cmds) {
			print "$cmds{$no}{name}::$cmds{$no}{plugin}::$cmds{$no}{performance} " if (defined($cmds{$no}{performance}));
		}
	} elsif ($opt{report} & $DETAIL_PERFORMANCE_CLASSIC) {
		printf "\|";
		#--- one line per command, format: tag=output
		foreach $no (sort numerically keys %cmds) {
			print "$cmds{$no}{performance} " if (defined($cmds{$no}{performance}));
		}
	}
}

#-------------------------------------------------------------------------------
#--- main ----------------------------------------------------------------------
#-------------------------------------------------------------------------------

#--- parse command line options
exit $UNKNOWN if (&process_parameters != $OK);

#--- parse command file (nrpe format)
&parse_commands($opt{filename});

#--- initialize timer for overall timeout
$rc{starttime}=time;
$rc{endtime}=$rc{starttime} + $opt{TIMEOUT};

#--- loop over commands in order of config file
foreach $no (sort numerically keys %cmds) {
	
	#--- if total timeout is going to be exceeded, cancel next commands
	if (time + $opt{timeout} > $rc{endtime}) {
		$cmds{$no}{output}="UNKNOWN - execution cancelled after global timeout ($opt{TIMEOUT}s)";
		$cmds{$no}{rc}=$UNKNOWN;
		$rc{count}{$UNKNOWN}++;
		$rc{list}{$UNKNOWN}.="$cmds{$no}{name},";
		next;
	}
		
	#--- execute command
	&exec_command($no);
}

#--- prepare output
&do_result_rating;

#--- classical report
if (! ($opt{report} & $DETAIL_HTML)) {
	&do_report;
}
#--- report HTML output
if ($opt{report} & $DETAIL_HTML) {
	&do_report_html;
}
#--- need XML data
if ($opt{report} & $DETAIL_XML) {
	&do_report_xml;
}

#--- at last: perfdata
&do_report_perfdata;

#--- return rc with highest severity
exit $rc{top};
