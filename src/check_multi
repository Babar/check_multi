#!/usr/bin/perl -w
#
# check_multi - nagios plugin
#
# Copyright (c) 2007 Matthias Flacke
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#
#
# $Header: /local/nagios/check_multi/RCS/check_multi,v 0.04 2007/06/20 21:23:24 root Exp $
#
#nagios: -epn
#
# TODO:
#
# - Performance output (warn Joerg before ;-)
# - embedding of runtime errors in output
# - handling of undefined RC 
# - customizeable return code handling
# - libexec: configure script
#
use strict;
use Getopt::Long qw(:config no_ignore_case bundling);
use lib "/usr/local/nagios/libexec";
use vars qw($MYSELF $OK $WARNING $CRITICAL $UNKNOWN %cmds $returncode %rc $VERSION $DETAIL_LIST $DETAIL_RC);

#--- Vars ----------------------------------------------------------------------------
#
$MYSELF="check_multi";
$VERSION="0.2";
#
#--- defines RC
$OK=0;
$WARNING=1;
$CRITICAL=2;
$UNKNOWN=3;
#--- defines verbosity
$DETAIL_LIST=1;
$DETAIL_RC=2;
#
%cmds=();
$returncode=0;
%rc=(
	label => {
		$OK => "OK",
		$WARNING => "WARNING",
		$CRITICAL => "CRITICAL",
		$UNKNOWN => "UNKNOWN",
	},
	r2s => {
		$OK => 0,	
		$WARNING => 2,	
		$CRITICAL => 3,
		$UNKNOWN => 1,	
	},
	s2r => {
		0 => $OK,
		2 => $WARNING,
		3 => $CRITICAL,
		1 => $UNKNOWN,
	},
	count => {
		$OK => 0,
		$WARNING => 0,
		$CRITICAL => 0,
		$UNKNOWN => 0,
	},
	list => {
		$OK => "",
		$WARNING => "",
		$CRITICAL => "",
		$UNKNOWN => "",
	},
	top => $OK,
	starttime => 0,
	endtime => 0,
);
	
 
my %opt=(
	"configfile"	=> "",
	"verbose"	=> 3,
	"libexec"	=> "/usr/local/nagios/libexec",
	"name"		=> "MULTI",
	"performance"	=> 0,
	"timeout"	=> 10,
	"overall"	=> 60,
);

#--- Subs ----------------------------------------------------------------------------

sub process_parameters {

	if (! GetOptions(
		"f|filename=s"	=> \$opt{filename},
		"h|help"	=> \$opt{help},
		"l|libexec=s"	=> \$opt{libexec},
		"n|name=s"	=> \$opt{name},
		"o|overall=i"	=> \$opt{overall},
		"p|performance"	=> \$opt{performance},
		"t|timeout=i"	=> \$opt{timeout},
		"v|verbose:i"	=> \$opt{verbose},
		"V|version"	=> \$opt{version},)
	) {
		short_usage();
        	exit $UNKNOWN;
	}
 
	if ($opt{version}) {
		print "$MYSELF: v$VERSION\n";
        	exit $OK;
	}

	if ($opt{help}) {
		short_usage();
        	long_usage();
        	exit $OK;
	}
 
	if (! $opt{filename}) {
        	print "Error: No config file specified\n";
		short_usage();
        	exit $UNKNOWN;
	}
}

sub short_usage {
print <<SHORTEOF; 

$MYSELF -f <config file> [-l libexec_path] [-n name] [-t timeout] [-o overall] [-p] [-d level]
$MYSELF [-h | --help]
$MYSELF [-V | --version]

SHORTEOF
}

sub long_usage {
print <<LONGEOF; 

Options:
-f, --filename
   config file which contains commands to be executed
   (file format follows nrpe style)
-l, --libexec
   path to plugins, default: $opt{libexec}
-n, --name
   plugin name (shown in output), default: MULTI
-t, --timeout
   timeout for one command, default: 10
-o, --overall
   timeout for all commands, default: 60
-p, --performance
   gather performance data, default: no
-v, --verbose <level>
   specify level of details in output (level is binary coded)
   default: 3
      1: mention service names in plugin_output, e.g. 
         "24 plugins checked, 1 critical (http), 0 warning, 0 unknown, 23 ok"
      2: show STATE in front of each line of plugin output
         "[16] OK system_ssh - SSH OK - OpenSSH_4.4 (protocol 1.99)"
-h, --help
   print detailed help screen
-V, --version
   print version information

LONGEOF
}

sub numerically { $a <=> $b }

sub mytrim { 
	my ($src, $trim)=@_;
	if ($src=~/[$trim]*(.*)[$trim]*/) {
		return $1;
	} else {
		return $src;
	}
}

sub mylist {
	my ($list)=@_;
	chop $list if ($list=~/,$/);
	$list=" ($list)" if ($list ne "");
	return $list;
}

#--- parse command file and fill %cmds structure
sub parse_commands {
	my ($filename, $cmds)=@_;
	my $lineno=0;
	my $cmd_count=0;
	my ($cmd,$name,$plugin);

	open(FILE, $filename) || die "UNKNOWN - cannot open config file $filename:$!";
	while (<FILE>) {
		$lineno++;
		next if (/^\s*$/);	# skip empty lines
		next if (/^\s*#/);	# skip comments
	
		chop($cmd=$_);

		if ($cmd=~/\s*command\s*\[\s*(\S+)\s*\]\s*=\s*(.*)\s*/i) {
			$name=$1;
			$cmd=$2;
			$plugin=(split(/\s+/,"$cmd"))[0];
		} else {
			print STDERR "Invalid format in line $lineno: $cmd\n";
			next;
		}

		#--- store vars
		if (! -f "$opt{libexec}/$plugin") {
			print STDERR "Error: plugin $plugin not found in $opt{libexec}\n";
		} elsif (! -x "$opt{libexec}/$plugin") {
			print STDERR "Error: plugin $opt{libexec}/$plugin not executable\n";
		} else {
			$cmds{++$cmd_count}{command}=$cmd;
			$cmds{$cmd_count}{plugin}=$plugin;
			$cmds{$cmd_count}{name}=$name;
		}
		#print "DEBUG: [$cmd_count] $cmd\n";
	}
	close FILE;
	return $cmd_count;
}

#--- Main ----------------------------------------------------------------------------

#--- parse command line options
process_parameters();

#--- parse command file (nrpe format)
if (! parse_commands($opt{filename},\%cmds)) {
	print "UNKNOWN - no commands specified in $opt{filename}\n";
	exit $UNKNOWN;
}

#--- initialize timeout timer
$rc{starttime}=time;
$rc{endtime}=$rc{starttime} + $opt{overall};

#--- loop over commands in order of config file
foreach my $no (sort numerically keys %cmds) {

	#--- if total timeout is going to be exceeded, cancel next commands
	if (time + $opt{timeout} > $rc{endtime}) {
		$cmds{$no}{output}="UNKNOWN - execution cancelled after global timeout ($opt{overall}s)";
		$cmds{$no}{rc}=$UNKNOWN;
		$rc{count}{$UNKNOWN}++;
		$rc{list}{$UNKNOWN}.="$cmds{$no}{name},";
		next;
	}

	#--- execute command with alarm timer to catch timeouts
	$SIG{'ALRM'} = sub { die "timeout" };
	eval {
		alarm($opt{timeout});

		#--- execute command and store stdout/return code
		$cmds{$no}{output}=`$opt{libexec}/$cmds{$no}{command}`;
		$cmds{$no}{rc}=$? >> 8;

		#--- no output on stdout? then take STDERR and provide returncode UNKNOWN
		if ($cmds{$no}{output} eq "") {
			$cmds{$no}{output}="UNKNOWN - STDERR:".`$opt{libexec}/$cmds{$no}{command} 2>&1`;
			$cmds{$no}{rc}=$UNKNOWN if ($cmds{$no}{rc}==$OK);
		}

#@all = `($cmd | sed -e 's/^/stdout: /' ) 2>&1`;
#for (@all) { push @{ s/stdout: // ? \@outlines : \@errlines }, $_ }
#print "STDOUT:\n", @outlines, "\n";
#print "STDERR:\n", @errlines, "\n";

		alarm(0);
	};
	
	#--- any oddities during command execution?
	if ($@) {
		#--- timeout encountered: store status
		if ($@ =~ /timeout/) {
			$cmds{$no}{output}="UNKNOWN - $cmds{$no}{plugin} cancelled after timeout ($opt{timeout}s)\n"; 
			$cmds{$no}{rc}=$UNKNOWN; 
		#--- catchall for unknown errors
		} else {
			alarm(0);
       			die "Unexpected exception encountered:$!";
		} 
	}
	#--- unknown return code? change it explicitly to UNKNOWN
	$cmds{$no}{rc}=$UNKNOWN if (! $cmds{$no}{rc} > $UNKNOWN);

	#--- do some statistics: sort and count return codes
	$rc{count}{$cmds{$no}{rc}}++;
	$rc{list}{$cmds{$no}{rc}}.="$cmds{$no}{name},";
	#print STDERR "DEBUG: rc:$cmds{$no}{rc} ok:$rc{count}{$OK} unknown:$rc{count}{$UNKNOWN} warning:$rc{count}{$WARNING} critical:$rc{count}{$CRITICAL}\n";

	#--- determine return code with highest severity
	$rc{top}=$cmds{$no}{rc} if ($rc{r2s}{$cmds{$no}{rc}} > $rc{r2s}{$rc{top}});
}

#--- print summary line with return code sums (plugin output)
if ($opt{verbose} & $DETAIL_LIST) {
	print "$opt{name} $rc{label}{$rc{top}} - ".keys(%cmds)." plugins checked, " . 
		"$rc{count}{$CRITICAL} critical" . mylist($rc{list}{$CRITICAL}) . ", " .
		"$rc{count}{$WARNING} warning" . mylist($rc{list}{$WARNING}) . ", " .
		"$rc{count}{$UNKNOWN} unknown" . mylist($rc{list}{$UNKNOWN}) . ", " .
		"$rc{count}{$OK} ok\n";
} else {
	#--- print summary line with return code sums (plugin output)
	print "$opt{name} $rc{label}{$rc{top}} - ".keys(%cmds)." plugins checked, " . 
		"$rc{count}{$CRITICAL} critical, " . 
		"$rc{count}{$WARNING} warning, " . 
		"$rc{count}{$UNKNOWN} unknown, " . 
		"$rc{count}{$OK} ok\n"; 
}

#--- report particular results for long plugin output
foreach my $no (sort numerically keys %cmds) {
	#printf "[%2.d][%s] %s - ",$no,substr($rc{label}{$cmds{$no}{rc}},0,2),$cmds{$no}{name};
	if ($opt{verbose} & $DETAIL_RC) {
		printf "[%2.d] %s %s - ",$no,substr($rc{label}{$cmds{$no}{rc}},0,10),$cmds{$no}{name};
	} else {
		printf "[%2.d] %s - ",$no,$cmds{$no}{name};
	}
	$cmds{$no}{output}=mytrim($cmds{$no}{output},"\\n\\s");
	if ($opt{performance} || $cmds{$no}{output}!~/(.*)\|/) {
		print $cmds{$no}{output};
	} else {
		print $1;
	}
	print "\n";
}

#--- return rc with highest severity
exit $rc{top};
