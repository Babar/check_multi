#!@client_perl@ -w
# nagios: -epn
#
# check_multi - nagios plugin
#
# Copyright (c) 2007-2009 Matthias Flacke (matthias.flacke at gmx.de)
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#
#
# $Id$
#
use strict; 
use Getopt::Long qw(:config no_ignore_case bundling);
use vars qw(
$MYSELF %cmds %opt $returncode %def %rc $no $VERSION $tmp_stdout $tmp_stderr $xml $check_multi
$status_dat
$OK $WARNING $CRITICAL $UNKNOWN
$DETAIL_LIST $DETAIL_LIST_FULL $DETAIL_HTML $DETAIL_STDERR $DETAIL_PERFORMANCE
$DETAIL_PERFORMANCE_CLASSIC $DETAIL_STATUS $DETAIL_PERFORMANCE_LINK $DETAIL_XML $DETAIL_NAGIOS2
$DETAIL_NOTES_LINK $DETAIL_SERVICE_DEFINITION $DETAIL_SEND_NSCA $DETAIL_FEED_PASSIVE
*DEBUG1 *DEBUG2 *DEBUG3 *DEBUG4
);
BEGIN {
	#--- if hires timer available, use it
	eval("use Time::HiRes qw(time)");
	#--- if FindBin module available, use it for finding plugins
	if (@findbin@) {
		eval("use FindBin");
		if (! $@) {
			$opt{set}{libexec}="$FindBin::Bin";
			unshift @INC, "$FindBin::Bin";
		}
	}
}
use lib "@libexecdir@";
#-------------------------------------------------------------------------------
#--- vars ----------------------------------------------------------------------
#-------------------------------------------------------------------------------
$MYSELF="check_multi";
$VERSION='$Revision$ $Date$ $Author$';
#
#--- RC defines
$OK=0;
$WARNING=1;
$CRITICAL=2;
$UNKNOWN=3;
#
#--- report defines
$DETAIL_LIST=1;
$DETAIL_HTML=2;
$DETAIL_STDERR=4;
$DETAIL_PERFORMANCE=8;
$DETAIL_LIST_FULL=16;
$DETAIL_PERFORMANCE_CLASSIC=32;
$DETAIL_STATUS=64;
$DETAIL_PERFORMANCE_LINK=128;
$DETAIL_XML=256;
$DETAIL_NAGIOS2=512;
$DETAIL_NOTES_LINK=1024;
$DETAIL_SERVICE_DEFINITION=2048;
$DETAIL_SEND_NSCA=4096;
$DETAIL_FEED_PASSIVE=8192;
#
#--- vars
$no=0;
$returncode=0;
$status_dat=undef;
$tmp_stdout="";
$tmp_stderr="";
%def=(
	label	=> { $OK  => "OK", $WARNING  => "WARNING", $CRITICAL  => "CRITICAL", $UNKNOWN  => "UNKNOWN", },
	code	=> { "OK" => $OK,  "WARNING" => $WARNING,  "CRITICAL" => $CRITICAL,  "UNKNOWN" => $UNKNOWN,
		     "ok" => $OK,  "warning" => $WARNING,  "critical" => $CRITICAL,  "unknown" => $UNKNOWN,  },
	s2r	=> { 0    => $OK,  2         => $WARNING,  3          => $CRITICAL,  1         => $UNKNOWN,  },
	r2s	=> { $OK  => 0,    $WARNING  => 2,         $CRITICAL  => 3,          $UNKNOWN  => 1,         },
	color	=> { $OK => "#33FF00", $WARNING => "#FFFF00", $CRITICAL => "#F83838", $UNKNOWN => "#FF9900", },
	bgcolor	=> { $OK => "#33FF00", $WARNING => "#FEFFC1", $CRITICAL => "#FFBBBB", $UNKNOWN => "#FFDA9F", },
);
my %opt=(
	"execute"	=> [],
	"filename"	=> [],
	"help"		=> 0,
	"set"		=> {
		# mouse_over & action_url: shows PNP chart popup triggered by mouse
		action_mouseover => @action_mouseover@,
		# checkresults_dir
		checkresults_dir => "@checkresults_dir@",
		# update config file (if HTTP/FTP/etc) once a day (in seconds)
		cmdfile_update_interval	=> @cmdfile_update_interval@,
		# should check_multi collapse child check_multi checks per default?
		collapse	=> @collapse@,
		# path to check_multi config directory
		config_dir	=> "@config_dir@",
		# use open3 method to exec child checks
		exec_open3	=> @exec_open3@,
		# show child checks also in status view (only in HTML mode)
		extinfo_in_status => "@extinfo_in_status@",
		# standard extension of check_multi command files, 
		# to be searched in directories
		file_extension	=> "@file_extension@",
		# hostaddress, either determined from Nagios environment, or specified
		HOSTADDRESS	=> $ENV{NAGIOS_HOSTADDRESS},
		# hostname, either determined from Nagios environment, or specified
		HOSTNAME	=> $ENV{NAGIOS_HOSTNAME},
		# if set, return UNKNOWN if command file is not found
		ignore_missing_cmd_file => @ignore_missing_cmd_file@,
		# characters to cleanup from command files
		illegal_chars	=> "@illegal_chars@",
		# path to Nagios images
		image_path	=> "@image_path@",
		# indentation character(s)
		indent		=> "@indent@",
		# child checks indented?
		indent_label	=> @indent_label@,
		# plugin directory to be added to check_multi search path
		libexec		=> "@libexecdir@",
		# label to be shown in output: <name> OK, ...
		name		=> "@name@",
		# what RC should be returned if no checks are defined
		no_checks_rc	=> @no_checks_rc@,
		# see tag_notes_link: URL to be added
		notes_url	=> "@notes_url@",
		#--- send_nsca: path to send_nsca binary
		send_nsca	=> "@sbindir@/send_nsca",
		#--- send_nsca_cfg: path to send_nsca cfg file
		send_nsca_cfg	=> "@sysconfdir@/send_nsca.cfg",
		#--- send_nsca_opts: options to provide to send_nsca
		send_nsca_srv	=> "localhost",
		#--- send_nsca_opts: options to provide to send_nsca
		send_nsca_port	=> 5667,
		#--- send_nsca_opts: options to provide to send_nsca
		send_nsca_timeout => @child_timeout@,
		#--- send_nsca_opts: options to provide to send_nsca
		send_nsca_delim => ";", 
		# create persistent data
		persistent	=> @persistent@,
		# path to PNP cgis
		pnp_cgi	=> "@pnp_cgi@",
		# report option, binary coded as sum of detail options
		report		=> @report@,
		#
		service_definition_template => "@service_definition_template@",
		# path to status.dat 
		status_dat => "@localstatedir@/status.dat",
		# style of plus/minus char
		style_plus_minus => "style='color:#4444FF;line-height:0.3em;font-size:1.5em;cursor:crosshair'",
		# documentation URL to be added to child check tags
		tag_notes_link	=> "@tag_notes_link@",
		# frame target for action_url and notes_url
		target		=> "@target@",
		# internal development and test mode 
		test		=> 0,
		# temporary etc dir for local copies of configuration files
		tmp_etc		=> "@tmp_etc@",
		# child check timeout (small t)
		timeout		=> @child_timeout@,
		# global check_multi timeout (BIG T)
		TIMEOUT		=> @parent_timeout@,
		# directory where check_multi stores its temporary output files
		tmp_dir		=> "@tmp_dir@",
		# octal permissions of tmp_dir
		tmp_dir_permissions => "@tmp_dir_permissions@",
		# verbosity, from 1 (less verbose) to 3 (much verbose)
		verbose		=> @verbose@,
		# elements to be added to XML structure
		xml_elements	=> "name,rc,output,error,plugin,command,performance,starttime,endtime,runtime,type",
	},

	"ok"		=> undef,
	"warning"	=> undef,
	"critical"	=> undef,
	"unknown"	=> undef,
);
my @cmds=(
	{
		name	=> "",
		error	=> [ ],		# stderr and other errors
		starttime => 0.0,	# start timestamp
		timeouttime => 0.0,	# timeout timestamp
		endtime => 0.0,		# end timestamp
		runtime => 0.0,		# runtime in seconds
		nchecks => 0,		# number of child checks (displayed)
		nallchecks => 0,	# number of all child checks (with non-displayed checks)
		number	=> 0,		# current number of check (0 for head)
		output	=> "",		# output
		rc	=> $OK,		# return code
	}
);
my %rc=(
	count	=> [ 0, 0, 0, 0, ],	# count displayed RCs
	count_all => [ 0, 0, 0, 0, ],	# cound all RCs
	list	=> [ [],[],[],[], ],	# list of displayed child checks
	list_all => [ [],[],[],[], ],	# list of all child checks
	expr	=> [ "1", "COUNT(WARNING)>0", "COUNT(CRITICAL)>0", "COUNT(UNKNOWN)>0" ],
	match	=> [ 0, 0, 0, 0, ],	#
	head	=> $OK,			# overall RC
);
my $check_multi={
	cmds	=> \@cmds,
	rc	=> \%rc,
	opt	=> \%opt
};


	
#-------------------------------------------------------------------------------
#--- subs ----------------------------------------------------------------------
#-------------------------------------------------------------------------------


#---
#--- process command line parameters and STDIN (if any)
#---
sub process_input {

	my @SAVEARGV=@ARGV;
	#--- check version of modules
	if ($Getopt::Long::VERSION < 2.27) {
		print "Error: module Getopt::Long version $Getopt::Long::VERSION is too old, minimum version is 2.27\n";
		return $UNKNOWN;
	}

	if (! GetOptions(
		"f|filename=s"	=> \@{$opt{filename}},
		"h|help:+"	=> \$opt{help},
		"l|libexec=s"	=> \$opt{set}{libexec},
		"n|name=s"	=> \$opt{set}{name},
		"r|report=s"	=> \$opt{set}{report},
		"s|set=s"	=> \%{$opt{set}},
		"t|timeout=i"	=> \$opt{set}{timeout},
		"T|TIMEOUT=i"	=> \$opt{set}{TIMEOUT},
		"v|verbose:+"	=> \$opt{set}{verbose},
		"V|version"	=> \$opt{version},
		"x|execute=s"	=> \@{$opt{execute}},
		"o|O|ok=s"	=> \$opt{ok},
		"w|W|warning=s"	=> \$opt{warning},
		"c|C|critical=s"=> \$opt{critical},
		"u|U|unknown=s"	=> \$opt{unknown},)
	) {
		short_usage();
		return $UNKNOWN;
	}

	#--- 4 debug levels: 1. verbose 2. errors 3. detailed 4. programmers debugging
	*DEBUG1=($opt{set}{verbose}>=1) ? \&debug_message : sub {};
	*DEBUG2=($opt{set}{verbose}>=2) ? \&debug_message : sub {};
	*DEBUG3=($opt{set}{verbose}>=3) ? \&debug_message : sub {};
	*DEBUG4=($opt{set}{verbose}>=3) ? \&debug_message : sub {};

	#--- -V(ersion) option
	if ($opt{version}) {
		print "$MYSELF: v$VERSION\n";
		return $UNKNOWN;
	}

	#--- -h/--help shows long usage, -hh extended usage
	DEBUG3("opt{help}=$opt{help}");
	if ($opt{help} == 1) {
		short_usage();
		long_usage();
		return $UNKNOWN;
	} elsif ($opt{help} == 2) {
		short_usage();
		long_usage();
		extended_usage();
		return $UNKNOWN;
	} elsif ($opt{help} > 2) {
		short_usage();
		long_usage();
		extended_usage();
		detailed_usage();
		return $UNKNOWN;
	}

	#--- only read STDIN if feeded by a PIPE, otherwise it would block when empty
	my $stdin="";
	if (-p STDIN) {
		while (<STDIN>) { $stdin.=$_; }
	}
	if ($stdin) { 
		DEBUG3("process_input: found <STDIN> >$stdin<");

		#--- do we have input from check_multi XML report mode? (check_multi as filter)
		if ($stdin=~/check_multi_xml/) {
			#--- try to load module XML::Simple
			$opt{set}{use_xml_simple} = 1;
			unless (eval "require XML::Simple;1") {
				$opt{set}{use_xml_simple} = 0;
				DEBUG2("process_input: XML::Simple not available:$@");
			}
	
			#--- read in XML data and feed cmds structure
			if ($opt{set}{use_xml_simple}) {
				my $in=XML::Simple::XMLin(
					$stdin,
					KeyAttr=>["CHILD"=>"no"],	# index: child no
					ForceArray=>["CHILD"],		# force array also for one child
					SuppressEmpty=>"",		# if empty, add "" instead of {} empty hash
				);
				
                        	unless (eval "use Data::Dumper;1") {
                                	$opt{set}{test}=0;
                                	DEBUG2("process_input: Data::Dumper not available");
                        	} else {
                                	DEBUG3("process_input: Data::Dumper available");
					DEBUG3("XML input:\n" . Dumper($in));
                        	}
				for my $i (keys %{$in->{PARENT}->{CHILD}}) {
					#print "key $i\n";
					$cmds[$i]{no}=$i;	# index itself as 'no'
					$cmds[$i]{feeded}=1;	# mark this cmd as feeded
					foreach my $att (keys %{$in->{PARENT}->{CHILD}->{$i}}) {
						#print " att $att -> $in->{PARENT}->{CHILD}->{$i}->{$att}\n";
						$cmds[$i]{$att}=$in->{PARENT}->{CHILD}->{$i}->{$att};
					}
				}
				DEBUG3("\@cmds after filling from XML input\n" . Dumper(\@cmds));
			}
		}
	} else {
		DEBUG3("process_input: no <STDIN> found");
	}

	#--- check_multi uses a temporary directory, per default /tmp/check_multi
	#--- 1. create if not yet done
	if (! -d "$opt{set}{tmp_dir}") {
		mkdir "$opt{set}{tmp_dir}";
		chmod oct("$opt{set}{tmp_dir_permissions}"), "$opt{set}{tmp_dir}";
	}
	#--- 2. check if tmp_dir is available
	if (! -d "$opt{set}{tmp_dir}") {
		print "Error: could not create tmp directory $opt{set}{tmp_dir} as user " . getpwuid($<) . "\n";
		return $UNKNOWN;
	#--- 3. and at last: it has to be writeable
	} elsif (! -w "$opt{set}{tmp_dir}") {
		print "Error: cannot write to tmp directory $opt{set}{tmp_dir} as user " . getpwuid($<) . "\n";
		return $UNKNOWN;
	}

	#---
	#--- getting commands - either per command file or per command parameter

	#--- none of them? return UNKNOWN
	if (! $opt{filename}[0] && ! $opt{execute}[0] && !$stdin) {
		print "$MYSELF error: no config file(s) or command parameters specified\n";
		short_usage();
		return $UNKNOWN;
	}

	#--- if URL specified as filename: load LWP::Simple for retrieving command file
	if (grep {/http|ftp/} @{$opt{filename}}) {
		unless (eval "require LWP::Simple;1") {
			print "$MYSELF error: http/ftp config file(s) specified, but no LWP::Simple module is available\n";
			return $UNKNOWN;
		} else {
			$opt{set}{use_lwp_simple}=1;
			DEBUG3("process_input: LWP::Simple loaded");
		}
	}

	#--- loop over filename / URL / directory array
	for (my $i=0;$i<@{$opt{filename}}; $i++) {

		#--- 1. filename URL found
		if ($opt{filename}[$i]=~/\/\//) {
			DEBUG3("http/ftp URL specified: $opt{filename}[$i]");

			#--- LWP module NOT loaded?
 			if (!$opt{set}{use_lwp_simple}) {
				add_error("LWP::Simple module not available, could not get command file $opt{filename}[$i]");
				next;
			}
			#--- split path components of URL
			my ($host,$path,$file)=("","","");
			if ($opt{filename}[$i]=~/.*\/\/([^\/]+)([\/]*.*)/) {
				$host=$1; $path=$2;
				if ($path=~/(.*)\/(.*$opt{set}{file_extension})/) {
					$path=$1; $file=$2;
				}
				chop($path) if ($path && $path=~/\S+\/$/);
				$path=$1 if ($path && $path=~/\/(\S+)$/);
				if ($path eq "" || $file eq "") {
					print "$MYSELF error: empty path or filename specified in URL $opt{filename}[$i]\n";
					return $UNKNOWN;
				}
				DEBUG4("URL:$opt{filename}[$i] hostname:$host path:$path file:$file");
			}
			
			#--- create directory to store saved config files
			my $cmdfile_path="$opt{set}{tmp_dir}/$opt{set}{tmp_etc}/$host/$path";
			`mkdir -p "$cmdfile_path"` if (! -d "$cmdfile_path");

			#--- use ctime to determine if config file should be updated after
			#--- having reached cmdfile_update_interval
			my $cmdfile_age=time-(stat("$cmdfile_path/$file"))[10] if (-f "$cmdfile_path/$file");
			if (!-f "$cmdfile_path/$file" || 
			    $cmdfile_age>$opt{set}{cmdfile_update_interval}) {
				DEBUG3("$cmdfile_path/$file age is $cmdfile_age, greater than allowed interval $opt{set}{cmdfile_update_interval}");
				my $RC=LWP::Simple::mirror($opt{filename}[$i],"$cmdfile_path/$file");
				if (LWP::Simple::is_success($RC) || $RC == 304) {
					DEBUG3("Mirroring $opt{filename}[$i] to $cmdfile_path/$file OK: RC $RC");
					$opt{filename}[$i]="$cmdfile_path/$file";
					`touch $opt{filename}[$i]`;
				} else {
					DEBUG2("Error: mirroring $opt{filename}[$i] to $cmdfile_path/$file failed: $RC");
				}
			} else {
				DEBUG3("$opt{filename}[$i] is already downloaded $cmdfile_path/$file");
				$opt{filename}[$i]="$cmdfile_path/$file";
			}

		#--- 2. directory found? replace directory with '*cmd' files from these directories
		} elsif (-d $opt{filename}[$i]) {
			splice(@{$opt{filename}},$i,1,glob "$opt{filename}[$i]/*$opt{set}->{file_extension}");

		#--- 3. and at last: the simple filename
		} else {
			if (! -f $opt{filename}[$i] || ! -r $opt{filename}[$i]) {
				DEBUG2("Error: filename $opt{filename}[$i] not existing or not readable");
			}
		}
	}

	#--- report option candy - allow speaking strings '1+2+4+8' instead of bare '15'
	if ($opt{set}{report}=~/[0-9+]/) {
		my $sum=0;
		for (split(/\+/,$opt{set}{report})) {
			$sum+=$_;
		}
		DEBUG3("process_input: reportstring $opt{set}{report} converted into numerical value $sum");
		$opt{set}{report}=$sum;
	} elsif ($opt{set}{report}=~/[0-9]/) {
		# normal numeric value - do nothing
	} else {
		print "$MYSELF error: report option \'$opt{set}{report}\' contains invalid characters, allowed are numbers or 0-9+\n";
		return $UNKNOWN;
	}
	#--- report options - name
	if ($opt{set}{report} & $DETAIL_PERFORMANCE_LINK && !$opt{set}{name}) {
		$opt{set}{name}=$MYSELF;
		DEBUG3("process_input: performance report option set and no name defined: taking $MYSELF as name");
	}

	#--- report option - notes_url
	if ($opt{set}{report} & $DETAIL_NOTES_LINK && !$opt{set}{notes_url}) {
		$opt{set}{notes_url}=$ENV{NAGIOS_SERVICENOTESURL};
		DEBUG3("process_input: notes report option set - taking Nagios SERVICENOTESURL $ENV{NAGIOS_SERVICENOTESURL}");
	}

	#--- if no module HTML::Entities available - set var
	if ($opt{set}{report} & $DETAIL_HTML) {
		$opt{set}{use_html_entities} = 1;
		unless (eval "require HTML::Entities;1") {
			$opt{set}{use_html_entities} = 0;
			DEBUG2("process_input: HTML::Entities not available");
		}
	}

	#--- if no modules IPC::Open3 or IO::Select, use old backquote exec and temp files
	if ($opt{set}{exec_open3}) {
		unless (eval "use IPC::Open3;1") {
			$opt{set}{exec_open3}=0;
			DEBUG2("process_input: IPC::Open3 not available");
		}
	}
	if ($opt{set}{exec_open3}) {
		unless (eval "use IO::Select;1") {
			$opt{set}{exec_open3}=0;
			DEBUG2("process_input: IO::Select not available");
		}
		DEBUG3("process_input: IPC::Open3 and IO::Select modules loaded");
	}

	#--- set libexec-dir at the beginning of PATH var
	if ($opt{set}{libexec}) {
		$ENV{PATH}="$opt{set}{libexec}:$ENV{PATH}";
	}

	#--- all state definitions can be set via command line
	if ($opt{ok}) {
		$rc{expr}[$OK]=$opt{ok};
	}
	if ($opt{warning}) {
		$rc{expr}[$WARNING]=$opt{warning};
	}
	if ($opt{critical}) {
		$rc{expr}[$CRITICAL]=$opt{critical};
	}
	if ($opt{unknown}) {
		$rc{expr}[$UNKNOWN]=$opt{unknown};
	}

	#--- timeout checking: overall TIMEOUT has to be greater than child check timeout
	if ($opt{set}{timeout} && $opt{set}{TIMEOUT} && $opt{set}{timeout} > $opt{set}{TIMEOUT}) {
		print "$MYSELF: error - child timeout $opt{set}{timeout}s must not be greater than parent timeout $opt{set}{TIMEOUT}s\n";
		return $UNKNOWN;
	}

	#--- determine hostname
	if (!$opt{set}{HOSTNAME}) {
		$opt{set}{HOSTNAME}=`uname -n`;
		chomp($opt{set}{HOSTNAME});
	}
	
	#--- add all set options as environment variables, so client scripts can use it
	foreach my $option (sort keys(%{$opt{set}})) {
		$ENV{"MULTI_".$option}=$opt{set}{$option} if defined($opt{set}{$option});
	}

	#--- add _the_ parent pid as indicator of the absolute first instance in a check_multi tree
	#--- there can be multiple recursive called instances and they need to detect which is the first
	if (!defined($ENV{"MULTI_PPID"})) {
		$ENV{"MULTI_PPID"}=$$;
	}

	#--- persistency - on the way to check_multi 2.0
	if ($opt{set}{persistent}) {

		#--- try to load module XML::Simple
		$opt{set}{use_xml_simple} = 1;
		unless (eval "require XML::Simple;1") {
			$opt{set}{use_xml_simple} = 0;
			DEBUG2("process_input: XML::Simple not available:$@");
		}

		#--- successful load? 
		if ($opt{set}{use_xml_simple}) {

			#--- take filename to store persistent data from HOSTNAME-SERVICEDESC
			if ($ENV{MULTI_HOSTNAME} && $ENV{MULTI_SERVICEDESC}) {
				$cmds[0]{key}="$ENV{MULTI_HOSTNAME}-$ENV{MULTI_SERVICEDESC}";
			} elsif ($ENV{MULTI_HOSTNAME} && $ENV{NAGIOS_SERVICEDESC}) {
				$cmds[0]{key}="$ENV{MULTI_HOSTNAME}-$ENV{NAGIOS_SERVICEDESC}";
			} else {
				print "process_input: need HOSTNAME and SERVICEDESC for persistent mode.\nPlease specify -s HOSTNAME=<hostname> -s SERVICEDESC=<service description>\n";
				return $UNKNOWN;
			}

			#--- replace whitechar with underscore
			$cmds[0]{key}=~s/\s+/_/g;
			DEBUG3("process_input: command key: $cmds[0]{key}");

			#--- read persistent data 
			my $in;
			if (-f "$opt{set}{tmp_dir}/${MYSELF}_$cmds[0]{key}.xml") {
				DEBUG3("process_input: reading file $opt{set}{tmp_dir}/${MYSELF}_$cmds[0]{key}.xml");
				$in=XML::Simple::XMLin("$opt{set}{tmp_dir}/${MYSELF}_$cmds[0]{key}.xml",KeyAttr => [ ]);
			} else {
				DEBUG2("process_input: persistency file $opt{set}{tmp_dir}/${MYSELF}_$cmds[0]{key}.xml not found.");
			}

			#--- debug output per Data::Dumper
			unless (eval "use Data::Dumper;1") {
				$opt{set}{test}=0;
				DEBUG2("process_input: Data::Dumper not available");
			} else {
				DEBUG3("process_input: Data::Dumper module loaded");
				DEBUG3("process_input: loaded persistent data:");
				DEBUG3(Dumper($in));
			}
		}
	}

	#--- any remaining parameters are orphaned - tell the caller what's going wrong here
	if (@ARGV) {
		print "Error: orphaned parameters found on command line:";
		for (my $i=1; $#ARGV>-1; $i++) {
			print " ARG$i:",shift(@ARGV);
		}
		print "\n";
		return $UNKNOWN;
	}

	#--- do some debug output
	DEBUG3("\n$MYSELF".' $Id $');
	DEBUG3("Command line: $0 ".join(' ',@SAVEARGV));
	#DEBUG3("User: ".getlogin()." ($>)");

	#--- just debugging: print options
	foreach my $option (sort keys(%opt)) {
		DEBUG4("process_input: \$opt{$option}=$opt{$option}") if (defined($opt{$option}));
	}
	foreach my $option (sort keys(%{$opt{set}})) {
		DEBUG4("process_input: \$opt{set}{$option}=$opt{set}{$option}") if (defined($opt{set}{$option}));
	}

	return $OK;
}

#---
#--- short usage as quick reference
#---
sub short_usage {
print <<SHORTEOF;
Usage:
$MYSELF -f <config file> [-n name] [-t timeout] [-T TIMEOUT] 
	[-r level] [-l libexec_path] [-s option=value]
$MYSELF [-h | --help] [-hh extended help] [-hhh complete help]
$MYSELF [-v | --verbose]
$MYSELF [-V | --version]

[ more infos on http://my-plugin.de/check_multi ]

SHORTEOF
}

#---
#--- long usage as detailed help (if anything else fails: read the instruction)
#---
sub long_usage {
print <<LONGEOF;
Common options:
-f, --filename
   config file which contains commands to be executed
   multiple files can be specified serially
   if filename is a directory, all '.cmd' files will be taken
   (file format follows nrpe style: command[tag]=plugin command line)
-n, --name
   multi plugin name (shown in output), default:$opt{set}{name}
-r, --report <level>
   specify level of details in output (level is binary coded, just sum up all options)
   default:$opt{set}{report}
   see more details with extended help option -hh
-s, --set <option>=<value>
   <KEY>=<VALUE> - set multi variable \$<KEY>\$ to <VALUE>
   see more details with complete help option -hhh
-t, --timeout
   timeout for one command, default:$opt{set}{timeout}
-T, --TIMEOUT
   TIMEOUT for all commands, default:$opt{set}{TIMEOUT}
-l, --libexec
   path to plugins, default:$opt{set}{libexec}
-h, --help
   print detailed help screen (extended help with -hh, complete help with -hhh)
-v, --verbose
   prints debug output (multiple -v extend debug level) 
-V, --version
   print version information

Extended command line - command file options also available on command line:
-x, --execute "command [ tag ] = check_xyz"
-w, --warning  <expression>
-c, --critical <expression>
-u, --unknown  <expression>
-o, --ok       <expression>

LONGEOF

}

#---
#--- extended usage - report options
#---
sub extended_usage {
print <<EXTENDED_EOF;
Extended options:
-r, --report <level>
   specify level of details in output (level is binary coded, just sum up all options)
   default:$opt{set}{report}
        1: mention service names in plugin_output, e.g.
           "24 plugins checked, 1 critical (http), 0 warning, 0 unknown, 23 ok"
        2: add HTML coloring of output for extinfo
        4: show STDERR (if any) in each line of plugin output
        8: show performance data (with check_multi_style)
       16: show full list of states, normally '0 warning' is omitted
       32: show old type of performance data (without check_multi style)
       64: add explicit status (OK,WARNING,CRITICAL,UNKNOWN) in front of output
      128: add action link if performance data available
      256: XML: print structured XML output
      512: Nagios 2 compatibility: one summary line of output only
     1024: show notes_url
     2048: print Nagios service definition for passive check feeded by check_multi
     4096: send_nsca: all child checks will be reported to Nagios via send_nsca
     8192: checkresults_file: all child checks are reported to Nagios via checkresults_file

EXTENDED_EOF
}

#---
#--- details for set options
#---
sub detailed_usage {
print <<DETAILED_EOF;
Set options:
-s, --set <option>=<value>
   <KEY>=<VALUE> - set multi variable \$<KEY>\$ to <VALUE>
   action_mouseover=<PNP URL> - mouse triggers PNP popup chart
   cmdfile_update_interval=<seconds> - update config file (if HTTP/FTP/...), default:$opt{set}{cmdfile_update_interval}
   collapse=<0|1> - should check_multi collapse child check_multi checks? default:$opt{set}{collapse}
   config_dir=</path/to/config_dir> - path to check_multi config directory, default:$opt{set}{config_dir}
   exec_open3=<0|1> - use open3 method to exec child checks (to be tested though), default:$opt{set}{exec_open3}
   extinfo_in_status=<0|1> - show child checks also in Nagios status.cgi (HTML), default:$opt{set}{extinfo_in_status}
   file_extension=<ext> - standard file extension for config files, default:$opt{set}{file_extension}
   ignore_missing_cmd_file=<0|1> - don't complain if config file missing, default:$opt{set}{ignore_missing_cmd_file}
   illegal_chars=<characters> - specify characters to cleanup from command files
   image_path=</path/to/imagefiles> - relative path to Nagios imagefiles: default:$opt{set}{image_path}
   indent=<characters> - string to indent child checks, default:$opt{set}{indent}
   indent_label=<0|1> - indentation width is child check label width (HTML), default:$opt{set}{indent_label}
   libexec=</path/to/plugins> - directory to be added to search path: default:$opt{set}{libexec}
   name=<string> - label to be shown in output: <name> OK, default:$opt{set}{name}
   no_checks_rc=<RC> - which RC should be returned if no checks are defined, default:$opt{set}{no_checks_rc}
   notes_url=<URL> - URL to be added to child check, see Nagios notes_url
   persistent=<0|1> - run check_multi in persistent mode, default:$opt{set}{persistent}
   pnp_cgi=</path/to/PNP-CGIs> - specify path to PNP cgi scripts (including CGI), default:$opt{set}{pnp_cgi}
   report=<number> - binary coded report option, default:$opt{set}{report}
   send_nsca=<path/to/send_nsca> - path to send_nsca binary, default:$opt{set}{send_nsca}
   send_nsca_cfg=</path/to/send_nsca.cfg> -  path to send_nsca cfg file, default:$opt{set}{send_nsca_cfg}
   send_nsca_srv=<NSCA server> - server to send NSCA messages to, default:$opt{set}{send_nsca_srv}
   send_nsca_port=<port number> - port where NSCA daemon runs on NSCA server, default:$opt{set}{send_nsca_port}
   send_nsca_timeout=<seconds> -  timeout for send_nsca, default:$opt{set}{send_nsca_timeout}
   send_nsca_delim=<string> - delimiter characters to separate NSCA fields, default:$opt{set}{send_nsca_delim}
   service_definition_template=</path/to/template> - template for passive service definition
   status_dat=</path/to/status.dat> - where is Nagios status.dat? default:$opt{set}{status_dat}
   style_plus_minus=<HTML style> - style of HTML plus/minus characters
   suppress_perfdata=<tag1>[,<tag2>][,...] - don't provide perfdata for check tag1,tag2...
   suppress_service=<tag1>[,<tag2>][,...] - don't report service data for check tag1,tag2...
   tag_notes_link=<URL> - notes URL be added to child checks, default:$opt{set}{tag_notes_link}
   target=<target> - frame target for action_url and notes_url, default:$opt{set}{target}
   timeout=<seconds> - child check timeout (small t), default:$opt{set}{timeout}
   TIMEOUT=<seconds> - global check_multi timeout (BIG T), default:$opt{set}{TIMEOUT}
   tmp_dir=<directory> - path for temporary files, default:$opt{set}{tmp_dir}
   tmp_dir_permissions=<octal> - permissions of temporary directory, default:$opt{set}{tmp_dir_permissions}
   tmp_etc=<directory> - path for local copies of command files, default:$opt{set}{tmp_etc}
   verbose=<0|1|2> - level of verbosity, from 1 (less verbose) to 3 (much verbose), default:$opt{set}{verbose}
   xml_elements=<string> - elements to be added to XML structure

DETAILED_EOF
}

#---
#--- numerical sort
#---
sub numerically { $a <=> $b }

#---
#--- trim input string if found any chars from trim string
#---
sub mytrim {
	my ($src, $trim)=@_;
	DEBUG3("mytrim: src:\'$src\' trim:\'$trim\'");
	return ($src=~/[$trim]*(.*)[$trim]*/) ? $1 : $src;
}

#---
#--- substitute macros a la $HOSTNAME$ from environment
#---
sub substitute_macros {
	my ($input)=@_;

	if (! $input) {
		DEBUG3("substitute_macros: empty input - nothing to do");
		return $input;
	}

	DEBUG3("substitute_macros: checking $input");
	while ((my $var)=($input=~/\$([A-Za-z0-9_^\$]+)\$/)) {

		#--- 1. check for MULTI var
		if (defined($ENV{"MULTI_${var}"})) {
			DEBUG3("substitute_macros: replacing env var MULTI_${var} with $ENV{\"MULTI_${var}\"}");
			$input=~s/\$$var\$/$ENV{"MULTI_${var}"}/g;
		#--- 2. check for NAGIOS var
		} elsif (defined($ENV{"NAGIOS_${var}"})) {
			DEBUG3("substitute_macros: replacing env var NAGIOS_${var} with $ENV{\"NAGIOS_${var}\"}");
			$input=~s/\$$var\$/$ENV{"NAGIOS_${var}"}/g;
		#--- 3. nothing to substitute
		} else {
			$input=~s/\$$var\$//g;
			DEBUG3("substitute_macros: var NAGIOS_${var}/MULTI_${var} not defined: removed \$$var\$");
		}
	}
	return $input;
}

#---
#--- replaces keywords with real results
#---
sub substitute_states {
	my ($input)=@_;

	#--- empty input?
	if (! $input) {
		DEBUG3("substitute_states: empty input - nothing to do");
		return $input;
	}

	#--- 1. replace COUNT(WARNING)
	$input=~s/\bCOUNT\s*\(\s*(OK)\s*\)/$rc{count}[$OK]/ig;
	$input=~s/\bCOUNT\s*\(\s*(WARNING)\s*\)/$rc{count}[$WARNING]/ig;
	$input=~s/\bCOUNT\s*\(\s*(CRITICAL)\s*\)/$rc{count}[$CRITICAL]/ig;
	$input=~s/\bCOUNT\s*\(\s*(UNKNOWN)\s*\)/$rc{count}[$UNKNOWN]/ig;
	$input=~s/\bCOUNT\s*\(\s*(ALL)\s*\)/$#cmds/ig;

	#--- 2. replace all STATES (OK)
	$input=~s/\b(OK)\b/$OK/ig;
	$input=~s/\b(WARNING)\b/$WARNING/ig;
	$input=~s/\b(CRITICAL)\b/$CRITICAL/ig;
	$input=~s/\b(UNKNOWN)\b/$UNKNOWN/ig;

	#--- 3. replace all vars with RC
	for ($no=1;$no<=$#cmds;$no++) {
		$input=~s/\b($cmds[$no]{name})\b/$cmds[$no]{rc}/ig;
	}
	#--- 4. replace IGNORE
	$input=~s/\b(IGNORE)\b/(0==1)/ig;
	return $input;
}


#---
#--- sets result environment variables
#---
sub set_env_vars {
	my ($no)=@_;

	my $name=($no==0)?"head":$cmds[$no]{name};

	$ENV{"MULTI_$name"}="$cmds[$no]{output}";
	$ENV{"MULTI_STATE_$name"}="$cmds[$no]{rc}";
	$ENV{"MULTI_LABEL_$name"}="$def{label}{$cmds[$no]{rc}}";
	$ENV{"MULTI_${no}"}="$cmds[$no]{output}";
	$ENV{"MULTI_${no}_STATE"}="$cmds[$no]{rc}";
	$ENV{"MULTI_${no}_LABEL"}="$def{label}{$cmds[$no]{rc}}";

	DEBUG4("set_env_vars: 6 environment vars set\n" . 
		"1. MULTI_$name=\t$cmds[$no]{output}\n" . 
		"2. MULTI_STATE_$name=\t$cmds[$no]{rc}\n" .
		"3. MULTI_LABEL_$name=\t$def{label}{$cmds[$no]{rc}}\n" . 
		"4. MULTI_${no}=\t$cmds[$no]{output}\n" . 
		"5. MULTI_${no}_STATE=\t$cmds[$no]{rc}\n" .
		"6. MULTI_${no}_LABEL=\t$def{label}{$cmds[$no]{rc}}");

}

#---
#--- print debug message (see Macro DEBUG)
#---
sub debug_message {
	foreach (@_) {
		print "$_\n";
	}	
}

#---
#--- install signal handlers
#--- 
sub install_signal_handler {
	my ($handler, @signals)=@_;
	foreach my $signal (@signals) {
		$SIG{$signal} = \&signal_handler;
	}
}

#---
#--- got signal? report what we have and terminate savely
#--- 
sub signal_handler {
	my $signal=$_[0];

	#--- reinstall signal_handler (just paranoid ;)
	install_signal_handler(\install_signal_handler, $signal);

	#--- do reports before quitting
	add_error("Got signal $signal");
	&result_rating;
	&report_all;

	#--- cleanup end exit
	unlink $tmp_stdout, $tmp_stderr if (!$opt{set}{exec_open3});
	exit $rc{head};
}

#---
#--- add error(s) to global error list
#---
sub add_error {
	push @{$cmds[0]{error}}, @_;
	DEBUG3("add_error: added error message \'@_\'");
}

#---
#--- create unique tmpfile and try to create it
#---
sub get_tmpfile {
	my ($path,$prefix)=@_;
	my $attempt=0;
	my $tmpfile="";
	#--- check existance of path and create it if necessary
	if (! -d $path && ! mkdir($path,0700)) {
		add_error("get_tmpfile: error creating tmp_path $path:$!");
		return "";
	}
	#--- do 5 attempts to create tmpfile
	while ($attempt++ < 5) {
		my $suffix=int(rand(89999))+10000;
		$tmpfile="$path/$prefix.$suffix";
		next if (-f $tmpfile);
		if (open(TMP,">$tmpfile")) {
			close TMP;
			DEBUG4("get_tmpfile: created $tmpfile");
			return $tmpfile;
		}
	}
	add_error("get_tmpfile: giving up opening $tmpfile after $attempt attempts:$!");
	return "";
}

#---
#--- read file and return its contents
#---
sub readfile {
	my ($filename)=@_;
	open(FILE,$filename) || add_error("readfile: error opening $filename:$!") && return "";
	my @lines=<FILE>;
	close(FILE);
	return join("", @lines);
}

#---
#--- writes file and return its contents
#---
sub writefile {
	my ($filename,@lines)=@_;
	open(FILE,"$filename") || add_error("writefile: error opening $filename:$!") && return "";
	print FILE @lines;
	close(FILE);
	return join("", @lines);
}

#---
#--- parse command file and call line parser
#---
sub parse_files {
	my ($filenames)=@_;	# allow multiple filenames (array reference)
	my (@lines)=();

	#--- loop over filenames
	foreach my $filename (@{$filenames}) {

		if (!open(FILE, $filename)) {
			next if ($opt{set}{ignore_missing_cmd_file});
			add_error("parse_files: cannot open config file $filename: $!");
			$rc{head}=$UNKNOWN;		# head RC to UNKNOWN
			$rc{expr}[$OK]="0==1";	# OK: false
			next;
		} else {
			@lines=<FILE>;
			push @lines, ""; # add empty line to avoid last line eval problem
			close FILE;
		}
		DEBUG3("-" x 80);
		DEBUG3("parse_files: parsing file $filename with $#lines lines");
		DEBUG3("-" x 80);
	
		parse_lines(@lines);
	}
	return $#cmds+1;
}


#---
#--- parse command array and fill %cmds structure
#---
sub parse_lines {
	my @lines=@_;
	my ($line,$cmd,$type,$name,$plugin,$pplugin,$expr,$lineno,$i,$last_command);

	$lineno=0;	# count sourcefile lines
	DEBUG4("parse_lines: starting with " . $#cmds . " command(s)");
	LINE: while ($line=shift(@lines)) {

		#--- count lines
		$lineno++;		

		#--- skip empty lines and comments
		next LINE if ($line=~/^\s*$/);
		next LINE if ($line=~/^\s*#/);
		
		#--- remove unwanted characters from input line
		if ($line=~/$opt{set}{illegal_chars}/) {
			DEBUG2("Found illegal characters in line $lineno, removing them");
			$line=~s/$opt{set}{illegal_chars}//g;
		}

		#--- remove trailing backslash if any (compatibility mode)
		$line=~s/\\\s*$// if ($line=~/\\\s*/);

		#--- header line (regex contains all allowed commands)
		if (($type,$name,$cmd)=($line=~/^\s*(command|eval|eeval|statusdat|state|output)\s*\[\s*(\S+)\s*\]\s*=\s*(.*)\s*/i)) {

			#--- macros?
			$name=substitute_macros($name);

			#--- allowed characters: 'a-zA-Z0-9_:-'
			if ($name!~/^[\w:-]+$/) {
				#--- still macro '$' in name? then macro was not substituted
				if ($name=~/\$([^\$]+)\$/) {
					add_error("parse_lines: tag \'$name\' invalid - macro \$$1\$ not found");
				} elsif ($name eq "") {
					add_error("parse_lines: empty tag \'\' invalid");
				} else {
					add_error("parse_lines: tag \'$name\' invalid - using non allowed characters");
				}
				next LINE;
			}

			#--- store vars, last_command contains index of cmd or name of state
			$last_command=parse_header($type,$name,$cmd,$lineno);

		#--- proper header line with invalid keyword
		} elsif ($line=~/^\s*(\w+)\s*\[\s*\S+\s*\]\s*=.*/) {
			add_error("Invalid keyword \'$1\' specified, allowed are command,eval,eeval,statusdat,state,output");
			return;

		#--- continuation line for previous command
		} else {
			if ($last_command=~/OK|UNKNOWN|WARNING|CRITICAL/i) {
				$rc{expr}[$def{code}{lc($last_command)}].=$line;
			} elsif ($last_command > 0) {
				$cmds[$last_command]{command}.=$line;
			} else {
				add_error("parse_lines: invalid format in line $lineno: $line");
				next LINE;
			}
		}
	}
	DEBUG4("parse_lines: end - now we have " . $#cmds . " command(s)");
}

sub parse_header {
	my ($type,$name,$cmd,$lineno)=@_;

	my ($i,$host,$service);

	#--- overloading: if child check with same name exists, 
	#--- overload its attributes. Otherwise append new check
	if ($type eq "command" || $type=~/eval$/ || $type=~/statusdat/) {
		for ($i=1; $i<=$#cmds;$i++) {
			last if ($cmds[$i]{name} eq $name);
		}
		if (defined($cmds[$i])) { 
			DEBUG2(defined($cmds[$i]{command})
				? "parse_header: overloaded \'$name\' with $type \'$cmd\'" 
				: "parse_header: added \'$name\' with $type \'$cmd\'"
			);
		}
	}

	#--- format: 'command [ tag[::plugin] ] = plugin command line'
	if ($type eq "command") {

		#--- normally the plugin name is the first token of $cmd
		my $plugin="";
		if ($cmd=~/\s+/) {
			$plugin=(split(/\s+/,"$cmd"))[0];
			$plugin=~s/.*\///g; 	# basename(plugin) (thx Gerhard)
		} else {
			$plugin=$cmd;
		}
		my $pplugin=$plugin;

		#--- or it is specified in [ TAG::PLUGIN ]
		if ($name=~/::/) {
			($name,$pplugin)=split(/::/,$name);
		}

		$cmds[$i]{type}=$type;
		$cmds[$i]{name}=$name;
		$cmds[$i]{command}=$cmd;
		$cmds[$i]{plugin}=$plugin;
		$cmds[$i]{pplugin}=$pplugin;
		$cmds[$i]{rc}=$UNKNOWN;
		$cmds[$i]{displayed}=1;
		$cmds[0]{nallchecks}++;
		$cmds[0]{nchecks}++;
		$cmds[$i]{number}=$cmds[0]{nchecks};
		$cmds[$i]{output}="";
		$cmds[$i]{error}="";
		$cmds[$i]{runtime}=0;
		if ($opt{set}{suppress_perfdata} && 
			$opt{set}{suppress_perfdata}=~/\b$name\b/i) {
			$cmds[$i]{process_perfdata}=0;
			DEBUG2("parse_header: perfdata of [ $name ] will be suppressed");
		} else {
			$cmds[$i]{process_perfdata}=1;
		}

	#--- format: 'eval    [ tag[::plugin] ] = expression'
	} elsif ($type eq "eval") {
		$cmds[$i]{type}=$type;
		$cmds[$i]{name}=$name;
		$cmds[$i]{command}=$cmd;
		$cmds[$i]{plugin}="eval";
		$cmds[$i]{pplugin}="eval";
		$cmds[$i]{rc}=$UNKNOWN;
		$cmds[$i]{displayed}=0;
		$cmds[0]{nallchecks}++;
		$cmds[$i]{output}="";
		$cmds[$i]{error}="";
		$cmds[$i]{runtime}=0;
		if ($opt{set}{suppress_perfdata} && 
			$opt{set}{suppress_perfdata}=~/\b$name\b/i) {
			$cmds[$i]{process_perfdata}=0;
			DEBUG2("parse_header: perfdata of [ $name ] will be suppressed");
		} else {
			$cmds[$i]{process_perfdata}=1;
		}

	#--- format: 'eeval   [ tag[::plugin] ] = expression'
	} elsif ($type eq "eeval") {
		$cmds[$i]{type}=$type;
		$cmds[$i]{name}=$name;
		$cmds[$i]{command}=$cmd;
		$cmds[$i]{plugin}="eval";
		$cmds[$i]{pplugin}="eval";
		$cmds[$i]{rc}=$UNKNOWN;
		$cmds[$i]{displayed}=1;
		$cmds[0]{nallchecks}++;
		$cmds[0]{nchecks}++;
		$cmds[$i]{number}=$cmds[0]{nchecks};
		$cmds[$i]{output}="";
		$cmds[$i]{error}="";
		$cmds[$i]{runtime}=0;
		if ($opt{set}{suppress_perfdata} && 
			$opt{set}{suppress_perfdata}=~/\b$name\b/i) {
			$cmds[$i]{process_perfdata}=0;
			DEBUG2("parse_header: perfdata of [ $name ] will be suppressed");
		} else {
			$cmds[$i]{process_perfdata}=1;
		}

	#--- format: 'statusdat [ tag[::plugin] ] = host, service'
	} elsif ($type eq "statusdat") {

		#--- statusdat: split host and service from command, format: host:service
		if ($cmd=~/\s*([^:]*)\s*\:\s*(.*)\s*/) {
			DEBUG4("parse_header: expanding $1:$2");
			my @result=expand_status_dat_service($opt{set}{status_dat}, $1, $2);
			if (!defined($result[0])) {
				add_error("Could not expand host:service $1:$2 from status_dat $opt{set}{status_dat}");
				return -1;
			}
			while(@result) {
				$cmds[$i]{type}=$type;
				$cmds[$i]{command}=$cmd;
				$cmds[$i]{plugin}=undef;
				$cmds[$i]{pplugin}=undef;
				$cmds[$i]{rc}=$UNKNOWN;
				$cmds[0]{nallchecks}++;
				$cmds[0]{nchecks}++;
				$cmds[$i]{number}=$cmds[0]{nchecks};
				$cmds[$i]{displayed}=1;
				$cmds[$i]{output}="";
				$cmds[$i]{error}="";
				$cmds[$i]{runtime}=0;
				$cmds[$i]{host}=shift(@result);
				$cmds[$i]{service}=shift(@result);
				if ($cmds[$i]{host} eq "-1") {
					$cmds[$i]{host}="UNKNOWN";
					$cmds[$i]{service}="UNKNOWN";
				}
				$cmds[$i]{name}="${name}_$cmds[$i]{host}_$cmds[$i]{service}";
				DEBUG4("parse_header: added host:$cmds[$i]{host} / service:$cmds[$i]{service}");
				$i++;
			}
		} else {
			add_error("parse_header: invalid host or service in statusdat line \'$lineno\', format should be \'statusdat [ name ] = host:service\'"); 
			return -1;
		}

	#--- format: state [ {UNKNOWN,WARNING,CRITICAL,OK} ] = <perl expression>
	} elsif ($type eq "state") {
		#DEBUG1("def{code}{$name}:$def{code}{$name}");
		if (!defined($def{code}{$name})) {
			add_error("parse_header: invalid state code specified in line $lineno: $cmd");
			return -1;
		}
		#--- store state expression only if NOT set via commandline
		if (!defined($opt{lc($name)})) {
			DEBUG3("parse_header: added state{$def{code}{$name}} expression: $cmd");
			$rc{expr}[$def{code}{$name}]=$cmd; 
		} else {
			DEBUG3("parse_header: command line precedence over state expression. Using \$opt{$name}: $opt{$name}");
		}
		$i=$name;

	#--- format: output [ tag ] = formatstr, parm1, parm2, ...
	} elsif ($type eq "output") {
		my $found=0;
		if ($name=~/^(\d+)$/ && $name<=$#cmds) {
			($cmds[$1]{fmtstr},@{$cmds[$1]{parms}})=split(',',$cmd);
			$found=1;
		} elsif ($name=~/head/i) {
			($cmds[0]{fmtstr},@{$cmds[0]{parms}})=split(',',$cmd);
                        $found=1;
		} else {
			for ($i=0; $found==0 && $i<=$#cmds;$i++) {
				if ($cmds[$i]{name} eq $name) {
					($cmds[$i]{fmtstr},@{$cmds[$i]{parms}})=split(',',$cmd);
					$found=1;
				}
			}
		}
		if (!$found) {
			add_error("parse_header: invalid tag output [ $name ] specified in line $lineno, " .
				"possible reason: defined output statement before command / eval statement");
			return -1;
		}

	#--- no type found? then its invalid
	} else {
		add_error("store_header: unknown command type \'$type\'");
		return -1;
	}

	#--- return value: either number of changed command or name of state
	return $i;
}

#---
#--- execute command number $no from %cmds
#---
sub exec_command {
	my ($no)=@_;

	#--- start with proper RC
	$?=0;

	#--- at runtime: substitute $MACRO$ macros and states
	$cmds[$no]{command}=substitute_macros($cmds[$no]{command});
	chomp($cmds[$no]{command});
	$ENV{"MULTI_${no}_NAME"}=$cmds[$no]{name};
	DEBUG4("exec_command [ $no ] = >$cmds[$no]{command}<");

	#--- measure command runtime;
	$cmds[$no]{starttime}=time;

	if ($cmds[$no]{type} eq "command") {

		eval {
			alarm($opt{set}{timeout});
	
			#--- classic execution with temporary files
			if (!$opt{set}{exec_open3}) {

				#--- prepare tmpfiles for stdout and stderr
				$tmp_stdout=&get_tmpfile("$opt{set}{tmp_dir}", "${MYSELF}_stdout_$$");
				$tmp_stderr=&get_tmpfile("$opt{set}{tmp_dir}", "${MYSELF}_stderr_$$");
	
				#--- execute command and store stdout/stderr/return code
				if (!defined(my $child=fork())) {
    					die "cannot fork: $!";
				} elsif ($child==0) {
					exec("$cmds[$no]{command} 1>$tmp_stdout 2>$tmp_stderr");
				} else { 
					$SIG{'ALRM'} = sub { 
						add_error("$cmds[$no]{name}: timeout after $opt{set}{timeout}s"); 
						kill -15,$child; 
						sleep 1; 
						kill -9,$child; 
					};
					alarm($opt{set}{timeout});
					waitpid($child,0);
					alarm(0);
				}
				$cmds[$no]{rc}=$? >> 8;
				$ENV{"MULTI_${no}_RC"}=$cmds[$no]{rc};
				$ENV{"MULTI_${no}_RC_label"}=$def{label}{$cmds[$no]{rc}};
	
				#--- store stdout/stderr and cleanup tmpfiles
				$cmds[$no]{output}=readfile($tmp_stdout);
				DEBUG3("exec_command: raw output >$cmds[$no]{output}<");
				$cmds[$no]{error}=readfile($tmp_stderr);
				DEBUG3("exec_command: raw stderr >$cmds[$no]{error}<");
				unlink $tmp_stdout, $tmp_stderr;
				$cmds[$no]{output}=~s/[$opt{set}{illegal_chars}]*//g; chomp $cmds[$no]{output};	
				$cmds[$no]{error}=~s/[$opt{set}{illegal_chars}]*//g; chomp $cmds[$no]{error};

			#--- new open3 exec (to be tested carefully before getting standard ;-))
			} else {
				my $pid=open3(*CIN,*COUT,*CERR,$cmds[$no]{command});
				close(CIN); # not needed: close STDIN filehandle
				$SIG{CHLD}=sub {
					$cmds[$no]{rc}=$?>>8 if waitpid($pid, 0) > 0;
					DEBUG4("REAPER: status $cmds[$no]{rc} on $pid");
				};

				my $sel=IO::Select->new();
				$sel->add(*CERR,*COUT);
				while (my @ready = $sel->can_read) {
					foreach my $fh (@ready) {
						if (fileno($fh) == fileno(CERR)) {
							$cmds[$no]{error}.=scalar <CERR>; 
						} else {
							$cmds[$no]{output}.=scalar <COUT>; 
						}
						$sel->remove($fh) if eof($fh);
					}
				}
				close(COUT);
				close(CERR);
				DEBUG3("exec_command: open3 raw output >$cmds[$no]{output}<");
				DEBUG3("exec_command: open3 raw stderr >$cmds[$no]{error}<");
				chomp $cmds[$no]{output};	
				chomp $cmds[$no]{error};
			}

			#--- unknown return code? change it explicitly to UNKNOWN and add error
			#---    this prevents the result rating routine from dealing with erraneous RCs
			#---    but keeps the information 
			if (! defined($def{r2s}{$cmds[$no]{rc}})) {
				$cmds[$no]{error}.=" RC was $cmds[$no]{rc}!";
				$cmds[$no]{rc}=$UNKNOWN;
			}
			
			#--- remove white chars from output
			#$cmds[$no]{error}=~s/[\s]+/ /g;
			#DEBUG3("exec_command: raw stderr >$cmds[$no]{error}<");
			$cmds[$no]{stdout}=HTML::Entities::encode_entities($cmds[$no]{stdout}) if ($opt{set}{use_html_entities} && $cmds[$no]{stdout});
			$cmds[$no]{error}=HTML::Entities::encode_entities($cmds[$no]{error}) if ($opt{set}{use_html_entities} && $cmds[$no]{error});
	
			#--- split performance data from standard output
			if ($cmds[$no]{output}=~/\|/) {
				DEBUG4("exec_command(1): output contains \|");
				if ($cmds[$no]{output}=~/([^\n]*)\n(.*)/s) {
					DEBUG4("exec_command(2): output contains \\n");
					my $rest=$2;
					DEBUG4("exec_command(3): \$1:$1");
					DEBUG4("exec_command(4): \$2:$2");
					($cmds[$no]{output},$cmds[$no]{performance})=split(/\|/,$1);
					DEBUG4("exec_command(5): rest:>$rest<");
					if ($rest=~/(.*)\|(.*)/s) {
						$cmds[$no]{output}.="\n$1";
						$cmds[$no]{performance}.=" " if ($cmds[$no]{performance});
						$cmds[$no]{performance}.=join(' ', split(/\n/,$2));
					} else {
						$cmds[$no]{output}.="\n$rest";
					}
					DEBUG4("exec_command(6): output:$cmds[$no]{output} performance:$cmds[$no]{performance}");
				} else {
					($cmds[$no]{output},$cmds[$no]{performance})=split(/\|/,$cmds[$no]{output});
					DEBUG4("exec_command performance string: $cmds[$no]{performance}");
					$cmds[$no]{performance}=mytrim($cmds[$no]{performance},"\\s");
				}

				#--- check performance data and suppress if found errors
				if (($opt{set}{report} & $DETAIL_PERFORMANCE) && $cmds[$no]{process_perfdata}) {
					if (my $errstr=error_in_perfdata($cmds[$no]{performance})) {
						add_error("$cmds[$no]{name} perfdata discarded for $errstr");
						$cmds[$no]{performance}=undef;
					}
				}
			}
	
			alarm(0);
		};
	} elsif ($cmds[$no]{type} eq "eval" || $cmds[$no]{type} eq "eeval") {
		local $SIG{ALRM} = sub {
			add_error("$cmds[$no]{name}: timeout after $opt{set}{timeout}s");
		};
		alarm($opt{set}{timeout});
		$cmds[$no]{output}=eval($cmds[$no]{command});
		if ($cmds[$no]{type} eq "eeval") {
			$cmds[$no]{rc}=$?>>8;
         		#--- unknown return code? change it explicitly to UNKNOWN
         		if (! defined($def{r2s}{$cmds[$no]{rc}})) {
            			$cmds[$no]{error}.=" RC was $cmds[$no]{rc}!";
            			$cmds[$no]{rc}=$UNKNOWN;
         		}
		} elsif ($cmds[$no]{type} eq "eval") {
			$cmds[$no]{rc}=$OK;
		}
		if ($@) {
			$cmds[$no]{output}.="[$@]";
			$cmds[$no]{rc}=$WARNING;
		} else {
			chomp($cmds[$no]{output});
			$ENV{"MULTI_".$cmds[$no]{name}}="$cmds[$no]{output}";
			#--- split performance data from standard output
			if ($cmds[$no]{output}=~/\|/) {
				($cmds[$no]{output},$cmds[$no]{performance})=split(/\|/,$cmds[$no]{output});
				$cmds[$no]{performance}=mytrim($cmds[$no]{performance},"\\s");

				#--- check performance data and suppress if found errors
				if (($opt{set}{report} & $DETAIL_PERFORMANCE) && $cmds[$no]{process_perfdata}) {
					if (my $errstr=error_in_perfdata($cmds[$no]{performance})) {
						add_error("$cmds[$no]{name} perfdata discarded for $errstr");
						$cmds[$no]{performance}=undef;
					}
				}
			}
			DEBUG4("exec_command: environment var MULTI_$cmds[$no]{name}=$cmds[$no]{output}");
		}
		$cmds[$no]{endtime}=time;
		$cmds[$no]{runtime}=$cmds[$no]{endtime}-$cmds[$no]{starttime};
		alarm(0);
		return $cmds[$no]{rc};
	} elsif ($cmds[$no]{type} eq "statusdat") {
		alarm($opt{set}{timeout});
                ($cmds[$no]{rc},$cmds[$no]{output})=get_status_dat_service($opt{set}{status_dat},$cmds[$no]{host},$cmds[$no]{service});
		if ($cmds[$no]{rc} == -1) {
			add_error("statusdat $cmds[$no]{name}: cannot find service \'$cmds[$no]{service}\' on host \'$cmds[$no]{host}\' in \'$opt{set}{status_dat}\'");
			$cmds[$no]{rc}=$UNKNOWN;
		}
		$ENV{"MULTI_".$cmds[$no]{name}}="$cmds[$no]{output}";
	}
	$cmds[$no]{endtime}=time;
	$cmds[$no]{runtime}=$cmds[$no]{endtime}-$cmds[$no]{starttime};
	
	#--- any oddities during command execution?
	if ($@) {
		#--- timeout encountered: store status
		if ($@ =~ /timeout/) {
			$cmds[$no]{output}="UNKNOWN - $cmds[$no]{plugin} cancelled after timeout ($opt{set}{timeout}s)";
			$cmds[$no]{rc}=$UNKNOWN;
			$cmds[$no]{output}.=readfile($tmp_stdout);
			$cmds[$no]{error}.=readfile($tmp_stderr);
		#--- catchall for unknown errors
		} else {
			alarm(0);
			$cmds[$no]{rc}=$UNKNOWN;
			add_error("unexpected exception encountered:$@");
		}
		unlink $tmp_stdout, $tmp_stderr;
	} else {
		#--- set environment variable states
		set_env_vars($no);

		#--- suppress_perfdata set? ignore perfdata
		if ($cmds[$no]{process_perfdata} && $cmds[$no]{performance}) {
			$ENV{"MULTI_PERFDATA_".$cmds[$no]{name}}="$cmds[$no]{performance}";
			DEBUG4("exec_command: environment var MULTI_PERFDATA_$cmds[$no]{name}=$cmds[$no]{performance}");
		}
	}
	return $cmds[$no]{rc};
}

sub get_status_dat_service {
        my ($statusdat_path, $host_name, $service_description)=@_;

	if (!$host_name || !$service_description) {
		add_error("get_status_dat_service: empty host_name=$host_name or service_description=$service_description specified");
		return (-1,"");
	}
	if (!$status_dat) {
		DEBUG4("get_status_dat_service: 1st read, creating service tree");
		$status_dat=read_status_dat($statusdat_path);
		if (!$status_dat) {
			add_error("get_status_dat_service: could not read $statusdat_path");
			return (-1,"");
		}
	} else {
		DEBUG4("get_status_dat_service: subsequent read, reading from service tree");
	}
	if (! defined($status_dat->{$host_name}->{$service_description})) {
		DEBUG2("get_status_dat_service: did not found RC and output for $host_name:$service_description");
		return (-1,"");
	} else {
		DEBUG4("get_status_dat_service: found data for $host_name:$service_description: RC $status_dat->{$host_name}->{$service_description}->{current_state} and output \'$status_dat->{$host_name}->{$service_description}->{plugin_output}\', long_output \'$status_dat->{$host_name}->{$service_description}->{long_plugin_output}\'");
        	return (
			$status_dat->{$host_name}->{$service_description}->{current_state}, 
			$status_dat->{$host_name}->{$service_description}->{plugin_output}."\n".
			$status_dat->{$host_name}->{$service_description}->{long_plugin_output}
		);
	}
}

sub expand_status_dat_service {
        my ($statusdat_path, $host_name, $service_description)=@_;

	DEBUG4("expand_status_dat_service: expanding $host_name:$service_description");
	if (!$host_name || !$service_description) {
		add_error("expand_status_dat_service: empty host_name=$host_name or service_description=$service_description specified");
		return (undef,undef);
	}
	if (!$status_dat) {
		DEBUG4("expand_status_dat_service: 1st read, creating service tree");
		$status_dat=read_status_dat($statusdat_path);
		if (!$status_dat) {
			add_error("expand_status_dat_service: could not read $statusdat_path");
			return (undef,undef);
		}
	} else {
		DEBUG4("expand_status_dat_service: subsequent read, reading from service tree");
	}

	#--- expand simple tokens to REGEX, if necessary
	$host_name=($host_name=~/\/(.*)\//)?$1:'^'.$host_name.'$';
	$service_description=($service_description=~/\/(.*)\//)?$1:'^'.$service_description.'$';
	DEBUG4("expand_status_dat_service: $host_name:$service_description after REGEX preparation");

	my @result=();
	foreach my $host (sort keys(%{$status_dat})) {
		foreach my $service (sort keys(%{$status_dat->{$host}})) {
			if ($host=~/$host_name/ && $service=~/$service_description/) {
				push @result,$host;
				push @result,$service;
				DEBUG4("expand_status_dat_service: $host:$service matched $host_name:$service_description");
			#} else {
				#DEBUG4("expand_status_dat_service: $host:$service did not match $host_name:$service_description");
			}
		}
	}
	DEBUG4("expand_status_dat_service returns " . ($#result+1)/2 . " results");
	return @result;
}

sub read_status_dat {
	my ($statusdat_path)=@_;

	if (!open(DAT,$statusdat_path)) {
		add_error("read_status_dat: cannot open $statusdat_path:$!");
		return (-1,"");
	}

	#--- outer loop: look for type ${type}status
	while (<DAT>) {
		#--- read only services
		if (/^servicestatus\s+\{/) {
			my $plugin_output="";
			my $long_plugin_output="";
			my $current_state=0;
			my $host_name="";
			my $service_description="";

			while (<DAT>) {
				NEXT: if (/\thost_name=(.+)$/) {
					$host_name=$1;
				} elsif (/\tservice_description=(.+)$/) {
					$service_description=$1;
				} elsif (/\tcurrent_state=(.*)/) {
					$current_state=$1;
				} elsif (/\tplugin_output=(.*)/) {
					$plugin_output=$1;
				} elsif (/\tlong_plugin_output=(.*)/) {
					chomp($long_plugin_output=$1);
					while (<DAT>) {
						if (/^\t/) {
							goto NEXT;
						} else {
							chomp;
							$long_plugin_output.="\n$_";
						}
					}
				} elsif (/^\t\}$/) {
					$status_dat->{$host_name}->{$service_description}->{current_state}=$current_state;
					$status_dat->{$host_name}->{$service_description}->{plugin_output}=$plugin_output;
					$status_dat->{$host_name}->{$service_description}->{long_plugin_output}=$long_plugin_output;
					last;
				}
			}
		#--- skip other records
		} else {
			next;
		}
	}
	close DAT;
	return $status_dat;
}

#---
#--- eval state rules 
#---
sub eval_result {
	my ($input)=@_;
	my $input_org=$input;
	my $message="";

	#--- empty input?
	if (! $input) {
		DEBUG3("eval_result: empty input - nothing to do");
		return ($UNKNOWN, "eval_result: invalid empty input");
	}

 	#--- at runtime: substitute $MACRO$ macros and $STATES$
	$input=substitute_macros($input);
	$input=substitute_states($input);

	#--- evaluate expression
	my $result=eval "($input)";

	#--- catch error
	if ($@) {
		$message="Evaluation error in \'$input_org\': $@\n";
		$message=~s/\n/ /g;
		return (-1,$message);
	#--- return result
	} else {
		$message="eval_result: input:\'$input_org\' parsed:\'$input\' result:\'$result\'\n";
		$message=~s/\n/ /g;
		DEBUG4($message);
		return ($result,$message);
	}
}


#---
#--- split state string into token and return 
#--- array of hashes with start,end,token
#---
sub get_state_token {
	my ($state)=@_;
	#
	my @token=();
	my $tno=0;
	my $pos=0;
	my $start=0;
	my $end=0;
	my $instring=0;
	
	#--- read string (and one char more for handling of last token)
	for (my $pos=0; $pos<=length($state); $pos++) {

		my $char=substr($state,$pos,1);
		my $nextchar=($pos<length($state)-1) ? substr($state,$pos+1,1) : "";

		#--- skip white characters ' ' and '()'
		if ($char=~/[ ()]/) {
			if (!$instring) {
				$start++;
			}

		#--- '||' or '&&' found: token end detected
		} elsif (($char eq "|" && $nextchar eq "|") ||
		 	($char eq "&" && $nextchar eq "&") ||
		 	($char eq ""  && $nextchar eq "" )) {
			$token[$tno]{start}=$start;
			$token[$tno]{end}=$end;
			$token[$tno]{token}=substr($state,$start,$end-$start+1);
			$token[$tno]{substituted}=substitute_macros($token[$tno]{token});
			$token[$tno]{substituted}=substitute_states($token[$tno]{substituted});
			($token[$tno]{substate},$token[$tno]{message})=eval_result($token[$tno]{substituted});

			$tno++;
			$pos+=2;
			$start=$pos;
			$end=$pos;
			$instring=0;

		#--- normal token char
		} else {
			#--- token init
			if (!$instring) {
				$instring=1;
				$start=$pos;
				$end=$pos;
			} else {
				$end=$pos;
			}
		}
	}
	my $output="\n" . "0123456789" x 8 ."\n$state\n\n";
	$output.=sprintf "%3s %5s %5s   %s\n", "No", "Start", "End", "Token";

	for ($tno=0;$tno<=$#token;$tno++) {

		#--- squeeze blanks to beautify output
		$token[$tno]{token}=~s/  / /g;

		$output.=sprintf "%3d %5d %5d   >%s<\n", 
			$tno, 
			$token[$tno]{start},
			$token[$tno]{end},
			$token[$tno]{token};
	}
	#--- debugging
	DEBUG3($output);

	#--- return array
	@token;
}
	
sub state_string_ascii {
	my ($state)=@_;
	my $output="";
	my @token=get_state_token($state);
	for (my $tno=0;$tno<=$#token;$tno++) {
		$output.=sprintf "%11s. %-52s %s\n", 
			chr(97+$tno), 	# 'a'+$tno
			"'".$token[$tno]{token}."'" . " -> " .  "'".$token[$tno]{substituted}."'",
			($token[$tno]{substate}) ? "TRUE" : "FALSE";
	}
	$output;
}

#---
#--- calculate sums from %cmds and %rc
#---
sub result_rating {

	#--- measure runtime without reporting ;-)
	$cmds[0]{runtime}=time - $cmds[0]{starttime};

	#--- count return codes
	for ($no=1;$no<=$#cmds;$no++) {
		#--- count only displayed (without eval)
		if ($cmds[$no]{displayed}) {
			$rc{count}[$cmds[$no]{rc}]++; # count displayed return codes
			push @{$rc{list}[$cmds[$no]{rc}]},$cmds[$no]{name}; # add plugin to displayed list
		}
		#--- count all child checks
		$rc{count_all}[$cmds[$no]{rc}]++;	# count all return codes
		push @{$rc{list_all}[$cmds[$no]{rc}]},$cmds[$no]{name}; # add plugin to all list
	}
	
	foreach my $s (sort numerically keys %{$def{s2r}}) {
		$ENV{"MULTI_$def{label}{$s}_COUNT"}=$rc{count}[$s];
		$ENV{"MULTI_$def{label}{$s}_LIST"}=join(',',@{$rc{list}[$s]});
		$ENV{"MULTI_$def{label}{$s}_COUNT_ALL"}=$rc{count_all}[$s];
		$ENV{"MULTI_$def{label}{$s}_LIST_ALL"}=join(',',@{$rc{list_all}[$s]});
		
		my $state=$def{s2r}{$s};
		
		my ($result,$message)=eval_result($rc{expr}[$state]);
		if (! defined($result) || $result eq "") {
			; # do nothing
		} elsif ($result < 0) {
			add_error("result_rating: parsing error ($message)");
		} else {
			$rc{match}[$state]=1;
			$rc{head}=$state;

		}
	}
	#--- set several environment vars for 'head'
	set_env_vars(0);
}

#---
#--- start different report routines
#---
sub report_all {

	#--- some debugging first
	DEBUG4("MULTI Environment (sorted):\n" . `env | grep '^MULTI' | sort | sed 's/^/   /g'`);
	DEBUG4("NAGIOS Environment (sorted):\n" . `env | grep '^NAGIOS' | sort | sed 's/^/   /g'`);

	#--- construction site for persistence
	if ($opt{set}{persistent} && $opt{set}{use_xml_simple} && $cmds[0]{key}) {
                unless (eval "use Data::Dumper;1") {
                        $opt{set}{test}=0;
                        DEBUG2("report_all: Data::Dumper not available");
                } else {
                	DEBUG3("report_all: Data::Dumper module loaded");
			DEBUG4("report_all:" . Dumper($check_multi));
		}

		writefile(
			">$opt{set}{tmp_dir}/${MYSELF}_$cmds[0]{key}.xml", 
			XML::Simple::XMLout(
				$check_multi,
				NoAttr=>1,
				KeepRoot=>1,
				RootName=>"$MYSELF",
			)
		);
	}

	#--- print service definition
	if ($opt{set}{report} & $DETAIL_SERVICE_DEFINITION) {
		&report_service_definition;
		return; # 	no normal output here
	}

	#--- classical report
	if (! ($opt{set}{report} & $DETAIL_HTML) &&
	    ! ($opt{set}{report} & $DETAIL_XML)) {
		&report_ascii;
	}
	#--- report HTML output
	if ($opt{set}{report} & $DETAIL_HTML) {
		&report_html;
	} 
	#--- report XML output 
	if ($opt{set}{report} & $DETAIL_XML) {
		&report_xml;
	}
	#--- report to nsca (send_nsca wrapper)
	if ($opt{set}{report} & $DETAIL_SEND_NSCA) {
		&report_send_nsca;
	}
	#--- report to nsca (send_nsca wrapper)
	if ($opt{set}{report} & $DETAIL_FEED_PASSIVE) {
		&report_checkresult_file;
	}
	
	#--- at last: perfdata
	&report_perfdata;
	
	#--- final '\n' - dedicated to Wolfgang Barth ;-)
	if (	!($opt{set}{report} & $DETAIL_NAGIOS2) && 
		!($opt{set}{report} & $DETAIL_HTML) &&
		!($opt{set}{report} & $DETAIL_XML)) {
		print "\n";
	}
}

#---
#--- report results stored in %cmds (ASCII report)
#---
sub report_ascii {

	DEBUG1("\n","-" x 80);
	DEBUG1("Plugin output");
	DEBUG1("-" x 80);
	
	if (defined($cmds[0]{fmtstr})) {
		my $output="printf " . $cmds[0]{fmtstr};
	 	$output.="," . join(",",@{$cmds[0]{parms}}) if (defined($cmds[0]{parms}));
		$output=substitute_macros($output);
		DEBUG4("report_ascii: output [ head ] = \'$output\'");
		eval($output);
	} elsif ($opt{set}{report} & $DETAIL_NAGIOS2) {
		print "$opt{set}{name} " if $opt{set}{name};
		print "$def{label}{$rc{head}}";
	} else {
		#--- print header line (1): name, state, number of plugins
		print "$opt{set}{name} " if $opt{set}{name};
		print "$def{label}{$rc{head}} - $cmds[0]{nchecks} plugins checked, ";
	
		#--- print header line (2): summary for particular states 
		if ($opt{set}{report} & $DETAIL_LIST_FULL) {
			print	"$rc{count}[$CRITICAL] critical" . ((@{$rc{list}[$CRITICAL]}) ? " (" . join(', ',@{$rc{list}[$CRITICAL]}) . ')' : "") . ", " .
				"$rc{count}[$WARNING] warning"   . ((@{$rc{list}[$WARNING]})  ? " (" . join(', ',@{$rc{list}[$WARNING]})  . ')' : "") . ", " .
				"$rc{count}[$UNKNOWN] unknown"   . ((@{$rc{list}[$UNKNOWN]})  ? " (" . join(', ',@{$rc{list}[$UNKNOWN]})  . ')' : "") . ", " .
				"$rc{count}[$OK] ok";
		} elsif ($opt{set}{report} & $DETAIL_LIST) {
			my @r=();
			push @r, "$rc{count}[$CRITICAL] critical (" . join(', ',@{$rc{list}[$CRITICAL]}) . ")" if (@{$rc{list}[$CRITICAL]});
			push @r, "$rc{count}[$WARNING] warning ("   . join(', ',@{$rc{list}[$WARNING]})  . ")" if (@{$rc{list}[$WARNING]});
			push @r, "$rc{count}[$UNKNOWN] unknown ("   . join(', ',@{$rc{list}[$UNKNOWN]})  . ")" if (@{$rc{list}[$UNKNOWN]});
			push @r, "$rc{count}[$OK] ok" if (@{$rc{list}[$OK]});
			print join(", ", @r);
		} else {
			print	"$rc{count}[$CRITICAL] critical, " .
				"$rc{count}[$WARNING] warning, " .
				"$rc{count}[$UNKNOWN] unknown, " .
				"$rc{count}[$OK] ok";
		}
	}
	#--- print general errors if any occured
	print " [" . join(", ",@{$cmds[0]{error}}) . "]" if (defined($cmds[0]{error}[0]));
	
	#--- loop over commands: report particular results for long plugin output
	for ($no=1;$no<=$#cmds;$no++) {

		#--- special output statement defined?
		if (defined($cmds[$no]{fmtstr})) {
			my $output="printf " . $cmds[$no]{fmtstr};
	 		$output.="," . join(",",@{$cmds[$no]{parms}}) if (defined($cmds[$no]{parms}));
			$output=substitute_macros($output);
			DEBUG4("report_ascii: output [ $cmds[$no]{name} ] = \'$output\'");
			eval($output);
			next;
		}

		#--- skip eval
		next if ($cmds[$no]{type} eq "eval");

		#--- if NAGIOS2 output: skip $OK results
		if ($opt{set}{report} & $DETAIL_NAGIOS2) {
			next if ($cmds[$no]{rc} == $OK);
			$cmds[$no]{output}=~s/\n//g;
			$cmds[$no]{error}=~s/\n//g;
			printf ", %s %s%s",
				$cmds[$no]{name},
				$cmds[$no]{output},
				(defined($cmds[$no]{error}) && $cmds[$no]{error} ne "" && ($opt{set}{report} & $DETAIL_STDERR)) ?
			 	" [ STDERR: " . $cmds[$no]{error} . ']' : "";
		} else {
			$cmds[$no]{output}=~s/\n/\n$opt{set}{indent}/g;
			printf "%s[%2.d] %s %s%s%s",
				($opt{set}{report} & $DETAIL_NAGIOS2) ? ", " : "\n",
				$cmds[$no]{number},
				$cmds[$no]{name},
				($opt{set}{report} & $DETAIL_STATUS) ? "$def{label}{$cmds[$no]{rc}} " : "",
				($cmds[$no]{output}=~/\<!--(.*?)--\>/sg) ? $1 : $cmds[$no]{output},
				(defined($cmds[$no]{error}) && $cmds[$no]{error} ne "" && ($opt{set}{report} & $DETAIL_STDERR)) ?
			 	" [ STDERR: " . $cmds[$no]{error} . ']' : "";
		}
	}

	my $maxcmdlen=0;
	for ($no=1;$no<=$#cmds;$no++) {
		$maxcmdlen=length($cmds[$no]{name}) if (length($cmds[$no]{name})>$maxcmdlen);
	}

	#--- print results
	DEBUG1("\n","-" x 80);
	DEBUG1(sprintf("No   Name%sRuntime  RC Output", ' ' x ($maxcmdlen-3)));
	DEBUG1("-" x 80);
	for ($no=1;$no<=$#cmds;$no++) {
		DEBUG1(sprintf "[%2.d] %-${maxcmdlen}s %6.4fs %3d %s", $no, $cmds[$no]{name}, $cmds[$no]{runtime}, $cmds[$no]{rc}, $cmds[$no]{output});
		DEBUG1(sprintf "%s%-12s%s", ' ' x ($maxcmdlen+6), $cmds[$no]{type}, $cmds[$no]{command});
	}

	#--- print state settings and RC evaluation result
	DEBUG1("\n","-" x 80);
	DEBUG1(sprintf "%-8s %-55s %s", "State","Expression","Evaluates to");
	DEBUG1("-" x 80);
	foreach my $s (sort numerically keys %{$def{s2r}}) {
		DEBUG1(sprintf "%-8s %-55s %s", $def{label}{$def{s2r}{$s}}, $rc{expr}[$def{s2r}{$s}], ($rc{match}[$def{s2r}{$s}]) ? "TRUE" : "FALSE");
		DEBUG2(state_string_ascii($rc{expr}[$def{s2r}{$s}]));
	}
	DEBUG1("-" x 80);
	DEBUG1(sprintf "%8s %55s %s", "", "Overall state =>", $def{label}{$rc{head}});
	DEBUG1("-" x 80);
}

#---
#--- report results stored in %cmds (HTML report)
#---
sub report_html {
	my $output="";
	
	if (defined($cmds[0]{fmtstr})) {
		$output.="sprintf " . $cmds[0]{fmtstr};
	 	$output.="," . join(",",@{$cmds[0]{parms}}) if (defined($cmds[0]{parms}));
		$output=substitute_macros($output);
		DEBUG4("report_html: output [ head ] =  \'$output\'");
		$output=eval($output);
	} else {
		#--- print header line (1): name, state, number of plugins
		$output.="$opt{set}{name} " if $opt{set}{name};
		$output.="$def{label}{$rc{head}} - $cmds[0]{nchecks} plugins checked, ";
	
		#--- print header line (2): summary for particular states 
		if ($opt{set}{report} & $DETAIL_LIST_FULL) {
			$output.="$rc{count}[$CRITICAL] critical" . ((@{$rc{list}[$CRITICAL]}) ? " (" . join(', ',@{$rc{list}[$CRITICAL]}) . ')' : "") . ", " .
				"$rc{count}[$WARNING] warning"   . ((@{$rc{list}[$WARNING]})  ? " (" . join(', ',@{$rc{list}[$WARNING]})  . ')' : "") . ", " .
				"$rc{count}[$UNKNOWN] unknown"   . ((@{$rc{list}[$UNKNOWN]})  ? " (" . join(', ',@{$rc{list}[$UNKNOWN]})  . ')' : "") . ", " .
				"$rc{count}[$OK] ok";
		} elsif ($opt{set}{report} & $DETAIL_LIST) {
			my @r=();
			push @r, "$rc{count}[$CRITICAL] critical (" . join(', ',@{$rc{list}[$CRITICAL]}) . ")" if (@{$rc{list}[$CRITICAL]});
			push @r, "$rc{count}[$WARNING] warning ("   . join(', ',@{$rc{list}[$WARNING]})  . ")" if (@{$rc{list}[$WARNING]});
			push @r, "$rc{count}[$UNKNOWN] unknown ("   . join(', ',@{$rc{list}[$UNKNOWN]})  . ")" if (@{$rc{list}[$UNKNOWN]});
			push @r, "$rc{count}[$OK] ok" if (@{$rc{list}[$OK]});
			$output.=join(", ", @r);
		} else {
			$output.="$rc{count}[$CRITICAL] critical, " .
				"$rc{count}[$WARNING] warning, " .
				"$rc{count}[$UNKNOWN] unknown, " .
				"$rc{count}[$OK] ok";
		}
	}

	#--- print general errors if any occured
	$output.=" [" . join(", ",@{$cmds[0]{error}}) . "]" if (defined($cmds[0]{error}[0]));
	$output.=($opt{set}{extinfo_in_status})?"<br />":"\n";

	#--- collapse of contents with javascript
	if ($opt{set}{collapse} == 1) {
		$output.="<SCRIPT LANGUAGE='JavaScript'> function Toggle(node) { if (node.nextSibling.style.display == 'none') { if (node.childNodes.length > 0) { node.childNodes.item(0).replaceData(0,1,String.fromCharCode(8211)) } node.nextSibling.style.display = 'block' } else { if (node.childNodes.length > 0) { node.childNodes.item(0).replaceData(0,1,'+') } node.nextSibling.style.display = 'none' } } </SCRIPT>";
		if (($rc{head} == $OK && $ENV{"MULTI_PPID"} != $$) ||
		    ($rc{head} == $OK && $opt{set}{extinfo_in_status})) {
			$output.="<A onClick='Toggle(this)' ".$opt{set}{style_plus_minus}.">+</A>";
			$output.="<DIV style='display:none'>";
		} else {
			$output.="<A onClick='Toggle(this)' ".$opt{set}{style_plus_minus}.">&ndash;</A>";
			$output.="<DIV style='display:block'>";
		}
	}

	#--- loop over commands: report particular results for long plugin output
	$output.="<div><table style='border-left-width:1px; border-right-width:0px; border-left-style:dotted' id=multi_table>";
	for ($no=1;$no<=$#cmds;$no++) {
		#--- skip eval
		next if ($cmds[$no]{type} eq "eval");

		#--- allow commands to get tag name
		$ENV{"MULTI_TAG"}=$cmds[$no]{name};

		$output.=sprintf "<tr style='font-size:8pt'><td nowrap><table style='background-color:%s'><tr style='vertical-align:middle'><td style='font-size:6pt'>%2.d</td></tr></table></td>", 
			$def{color}{$cmds[$no]{rc}},
			$no;
		#--- Action url (standard version)
		if (	($opt{set}{report} & $DETAIL_PERFORMANCE) &&
			($opt{set}{report} & $DETAIL_PERFORMANCE_LINK) && 
			defined($cmds[$no]{performance}) &&
			$cmds[$no]{process_perfdata} &&
			!$opt{set}{action_mouseover}) {

			#--- determine hostname
			my $hostname="";
			if ($ENV{MULTI_HOSTNAME}) {
				$hostname=$ENV{MULTI_HOSTNAME};
			} elsif ($ENV{MULTI_HOSTADDRESS}) {
				$hostname=$ENV{MULTI_HOSTADDRESS};
			} else {
				$hostname=`uname -n`;
			}
			chomp($hostname);
			DEBUG3("report_html: hostname is $hostname");
			my $pnp_cgi=substitute_macros($opt{set}{pnp_cgi});
			my $image_path=substitute_macros($opt{set}{image_path});
			$output.=sprintf "<td nowrap>%s</td>", 
				"<A TARGET=\'$opt{set}{target}\' HREF=\'$pnp_cgi?host=${hostname}&srv=$cmds[$no]{name}\'> " . 
				"<img src=\'$image_path/action.gif\' width=20 height=20 border=0 align=top alt='Show performance chart for $hostname / $cmds[$no]{plugin}'></A>";
		#--- Action url (mouseover version)
		} elsif (($opt{set}{report} & $DETAIL_PERFORMANCE) &&
			($opt{set}{report} & $DETAIL_PERFORMANCE_LINK) && 
			defined($cmds[$no]{performance}) &&
			$cmds[$no]{process_perfdata} &&
			$opt{set}{action_mouseover}) {

			#--- determine hostname
			my $hostname="";
			if ($ENV{MULTI_HOSTNAME}) {
				$hostname=$ENV{MULTI_HOSTNAME};
			} elsif ($ENV{MULTI_HOSTADDRESS}) {
				$hostname=$ENV{MULTI_HOSTADDRESS};
			} else {
				$hostname=`uname -n`;
			}
			chomp($hostname);
			DEBUG3("report_html: hostname is $hostname");
			my $pnp_cgi=substitute_macros($opt{set}{pnp_cgi});
			my $image_path=substitute_macros($opt{set}{image_path});
			DEBUG4(">>>$opt{set}{target}:$pnp_cgi:${hostname}:$cmds{$no}{name}:${hostname}:$cmds{$no}{name}:$image_path:$hostname:$cmds{$no}{name}<<<");
			$output.=sprintf "<td nowrap>%s</td>",
				"<A TARGET=\'$opt{set}{target}\' HREF='/$pnp_cgi?host=${hostname}&srv=$cmds{$no}{name}' onmouseout='clear_g()' onmouseover=\"get_g(\'${hostname}\',\'$cmds{$no}{name}\')\">" .
				"<img src=\'$image_path/action.gif\' width=20 height=20 border=0 align=top alt='Show performance chart for $hostname / $cmds{$no}{name}'></A>";
		} else {
			$output.="<td></td>";
		}
		#--- Notes url
		if (	($opt{set}{report} & $DETAIL_NOTES_LINK) &&
			defined($opt{set}{notes_url}) &&
			!$opt{set}{tag_notes_link}) {
			my $notes_url=substitute_macros($opt{set}{notes_url});
			my $image_path=substitute_macros($opt{set}{image_path});
			$output.=sprintf "<td nowrap>%s</td>", 
				"<A HREF=\'$notes_url\' TARGET=\'$opt{set}{target}\'>" . 
				"<img src=\'$image_path/notes.gif\' width=20 height=20 border=0 align=top alt='Show notes for $cmds[$no]{plugin}'></A>";
		} else {
			$output.="<td></td>";
		}
		#--- and the rest...
		if (!$opt{set}{tag_notes_link}) {
			$output.=sprintf "<td>%s</td>", ($cmds[$no]{name}) ? $cmds[$no]{name} : "";
		} else {
			my $notes_url=substitute_macros($opt{set}{notes_url});
			$output.=sprintf "<td><A HREF=\'$notes_url\' TARGET=\'$opt{set}{target}\'>%s</A></td>", ($cmds[$no]{name}) ? $cmds[$no]{name} : "";
		}
		DEBUG3("report_html output:$cmds[$no]{output}");
		DEBUG3("HTML check_multi recursive levels: " . scalar ($cmds[$no]{output}=~s/multi_table/multi_table/g));
		if (defined($cmds[$no]{fmtstr})) {
			my $tmp="sprintf " . $cmds[$no]{fmtstr};
	 		$tmp.="," . join(",",@{$cmds[$no]{parms}}) if (defined($cmds[$no]{parms}));
			$tmp=substitute_macros($tmp);
			DEBUG4("report_html: output [ $cmds[$no]{name} ] = \'$tmp\'");
			$tmp=eval($tmp);
			$output.=sprintf "<td>%s</td>", 
					($tmp=~/^([^\n]+)\n(.*)/is) 
					? (($opt{set}{indent_label}) 
						? "$1</td></tr><tr style='font-size:8pt'><td colspan='4'></td><td colspan='1'>$2"
						: "$1</td></tr><tr><td></td><td colspan='5'>$2")
					: $tmp;
		} else {
			$output.=sprintf "<td>%s</td>", 
					($cmds[$no]{output}=~/^([^\n]+)\n(.*)/is) 
					? (($opt{set}{indent_label}) 
						? "$1</td></tr><tr style='font-size:8pt'><td colspan='4'></td><td colspan='1'>$2"
						: "$1</td></tr><tr><td></td><td colspan='5'>$2")
					: $cmds[$no]{output};
		}
		if (	defined($cmds[$no]{error}) && 
			$cmds[$no]{error} ne "" && 
			($opt{set}{report} & $DETAIL_STDERR)) {

			$output.=" [ STDERR: " . join('<br>',$cmds[$no]{error}) . "]";
		}
		$output.="</tr>";
	}
	$output.="</table></div>";
	$output.="</div>" if ($opt{set}{collapse} == 1 && ! $opt{set}{extinfo_in_status});

	#--- print state evaluation if verbose flag set
        if ($opt{set}{verbose} >= 2) {
		if ($ENV{"MULTI_PPID"} != $$) {
			$output.="<A onClick='Toggle(this)' style='".$opt{set}{style_plus_minus}."'>+</A>";
			$output.="<DIV style='display:none'><h4>Child check overview</h4>";
		}
		my @colors=("silver","lightgrey");
		my $flipflop=0;
		$output.="<table><tr style='text-align:left' bgcolor='" . $colors[$flipflop] . "'><th>No</th><th>Name</th><th>Runtime</th><th>RC</th><th>Output</th></tr>";
		for ($no=1;$no<=$#cmds;$no++) {
			$flipflop=!$flipflop;
			$output.=sprintf "<tr bgcolor='" . $colors[$flipflop] . "'><td>%d</td><td>%s</td><td>%7.5f</td><td>%d</td><td>%s</td></tr>", $no, $cmds[$no]{name}, $cmds[$no]{runtime}, $cmds[$no]{rc}, $cmds[$no]{output};
			$output.=sprintf "<tr bgcolor='" . $colors[$flipflop] . "'><td></td><td></td><td>%s</td><td></td><td>%s</td></tr>", $cmds[$no]{type}, $cmds[$no]{command};
		}
		$output.="</table></div>";

		#--- print state settings and RC evaluation result
		if ($ENV{"MULTI_PPID"} != $$) {
			$output.="<A onClick='Toggle(this)' style='".$opt{set}{style_plus_minus}."'>+</A>";
			$output.="<DIV style='display:none'><h4>State evaluation</h4>";
		}
		$flipflop=0;
		$output.="<table><tr style='text-align:left' bgcolor='" . $colors[$flipflop] . "'><th>State</th><th>Expression</th><th>Evaluates to</th></tr>";
		foreach my $s (sort numerically keys %{$def{s2r}}) {
			$flipflop=!$flipflop;
			$output.=sprintf "<tr bgcolor='" . $colors[$flipflop] . "'><td>%s</td><td>%s</td><td>%s</td></tr>", $def{label}{$def{s2r}{$s}}, $rc{expr}[$def{s2r}{$s}], ($rc{match}[$def{s2r}{$s}]) ? "TRUE" : "FALSE";
		}
		$flipflop=!$flipflop;
		$output.="<tr bgcolor='" . $colors[$flipflop] . "'><td></td><td style='text-align:right'>Overall state</td><td style='font-weight:bold'>$def{label}{$rc{head}}</td></tr>";
		$output.="</table></div>";
	}

	#--- verbose mode - add some tables
	if ($opt{set}{verbose} >=2) {

		if ($ENV{"MULTI_PPID"} != $$) {
			$output.="<A onClick='Toggle(this)' style='".$opt{set}{style_plus_minus}."'>+</A>";
			$output.="<DIV style='display:none'><h4>Child check details</h4>";
		}
		my @colors=("silver","lightgrey");
		my $flipflop=0;
		for ($no=1;$no<=$#cmds;$no++) {
			$output.="<h5>$no - $cmds[$no]{name}</h5>";
			$output.="<table><tr style='text-align:left' bgcolor='" . $colors[$flipflop] . "'><th></th><th>Attribute</th><th>Value</th></tr>";
			my %vars=(
				1 => {
					att => "\$no",	
					val => $no, 
				},
				2 => {
					att => "tag",	
					val => $cmds[$no]{name},	 
				},
				3 => {
					att => "\$STATE_$cmds[$no]{name}\$",
					val => $cmds[$no]{rc},
				},
				4 => {
					att => "\$$cmds[$no]{name}\$",
					val => $cmds[$no]{output},	
				},
				5 => {
					att => "type",			
					val => $cmds[$no]{type},	
				},
				6 => {
					att => "command",		
					val => $cmds[$no]{command},	 
				},
				7 => {
					att => "runtime",		
					val => $cmds[$no]{runtime},	 
				},
			);

			foreach my $i (sort keys %vars) {
				$flipflop=!$flipflop;
				$output.=sprintf "<tr bgcolor='" . $colors[$flipflop] . "'><td>%d</td><td>%s</td><td>%s</td></tr>", $i, $vars{$i}{att}, $vars{$i}{val};
			}
			$output.="</table>";
		}
		$output.="</div>";
	}
	
	#--- status_in_extinfo? escape newlines by '<br>'
	$output=~s/\n/<br \/>/g if ($opt{set}{extinfo_in_status});

	#--- last not least: output ;-)
	print $output;
}

#---
#--- report in XML (at the moment hidden in HTML comment)
#---
sub report_xml {

	my $xmlstr="<div id=\"check_multi_xml\" style='display:none'>";
	#$xmlstr.="<meta http-equiv=\"Content-Style-Type\" content=\"application/xml\">\n";
	$xmlstr.="<?xml version=\"1.0\"?>\n";
	$xmlstr.="<?xml-stylesheet type=\"text/xsl\" href=\"extinfo.xsl\"?>\n";
	$xmlstr.="<PARENT>\n";
	$xmlstr.="\t<name>$cmds[0]{name}</name>\n";
	$xmlstr.="\t<plugins>$cmds[0]{nchecks}</plugins>\n";
	$xmlstr.="\t<starttime>$cmds[0]{starttime}</starttime>\n";
	$xmlstr.="\t<endtime>$cmds[0]{endtime}</endtime>\n";
	$xmlstr.="\t<runtime>$cmds[0]{runtime}</runtime>\n";
	$xmlstr.="\t<output>";
	if (defined($cmds[0]{fmtstr})) {
		my $output="sprintf " . $cmds[0]{fmtstr};
	 	$output.="," . join(",",@{$cmds[0]{parms}}) if (defined($cmds[0]{parms}));
		$output=substitute_macros($output);
		DEBUG4("report_xml: output [ head ] = \'$output\'");
		$xmlstr.=eval($output);
	} else {
		#--- print header line (2): summary for particular states 
		if ($opt{set}{report} & $DETAIL_LIST_FULL) {
			$xmlstr.="$rc{count}[$CRITICAL] critical" . ((@{$rc{list}[$CRITICAL]}) ? " (" . join(', ',@{$rc{list}[$CRITICAL]}) . ')' : "") . ", " .
				"$rc{count}[$WARNING] warning"   . ((@{$rc{list}[$WARNING]})  ? " (" . join(', ',@{$rc{list}[$WARNING]})  . ')' : "") . ", " .
				"$rc{count}[$UNKNOWN] unknown"   . ((@{$rc{list}[$UNKNOWN]})  ? " (" . join(', ',@{$rc{list}[$UNKNOWN]})  . ')' : "") . ", " .
				"$rc{count}[$OK] ok";
		} elsif ($opt{set}{report} & $DETAIL_LIST) {
			my @r=();
			push @r, "$rc{count}[$CRITICAL] critical (" . join(', ',@{$rc{list}[$CRITICAL]}) . ")" if (@{$rc{list}[$CRITICAL]});
			push @r, "$rc{count}[$WARNING] warning ("   . join(', ',@{$rc{list}[$WARNING]})  . ")" if (@{$rc{list}[$WARNING]});
			push @r, "$rc{count}[$UNKNOWN] unknown ("   . join(', ',@{$rc{list}[$UNKNOWN]})  . ")" if (@{$rc{list}[$UNKNOWN]});
			push @r, "$rc{count}[$OK] ok" if (@{$rc{list}[$OK]});
			$xmlstr.=join(", ", @r);
		} else {
			$xmlstr.="$rc{count}[$CRITICAL] critical, " .
				"$rc{count}[$WARNING] warning, " .
				"$rc{count}[$UNKNOWN] unknown, " .
				"$rc{count}[$OK] ok";
		}
	}
	$xmlstr.="</output>\n";
	$xmlstr.="\t<error>" . join(", ",@{$cmds[0]{error}}) . "</error>\n" if (defined($cmds[0]{error}[0]));

	for ($no=1;$no<=$#cmds;$no++) {
		$xmlstr.="\t<CHILD>\n";
		$xmlstr.="\t\t<no>$no</no>\n";
		foreach my $token (split(/,/,$opt{set}{xml_elements})) {
			if (defined($cmds[$no]{$token})) {
				$xmlstr.=sprintf "\t\t<%s>%s</%s>\n",$token,$cmds[$no]{$token},$token;
			} else {
				add_error("report_xml: XML element $token not found");
			}
		}
		$xmlstr.="\t</CHILD>\n";
	}
	$xmlstr.="</PARENT>\n</div>\n";
	print $xmlstr;
}

#---
#--- print out all perfdata 
#---    if its compliant to developers guidelines ;)
#---
sub report_perfdata {
	if (!$opt{set}{report} & $DETAIL_HTML) {
		DEBUG1("\n","-" x 80);
		DEBUG1("Plugin performance data");
		DEBUG1("-" x 80);
	}
	#--- report performance data?
	if ($opt{set}{report} & $DETAIL_PERFORMANCE) {
		my $perftmp="";
		DEBUG3("report_perfdata (DETAIL_PERFORMANCE): name=" . ($opt{set}{name}) ? $opt{set}{name} : $MYSELF);
		print "\|";
		printf "%s::%s::plugins=%d time=%f ", 
			($opt{set}{name}) ? $opt{set}{name} : $MYSELF, $MYSELF,
			$cmds[0]{nallchecks},
			$cmds[0]{runtime};
		#--- one line per command, format: tag=output
		for ($no=1;$no<=$#cmds;$no++) {

			#--- suppress_perfdata set? ignore perfdata
			next if (! $cmds[$no]{process_perfdata});

			if (defined($cmds[$no]{performance})) {
				#--- prevent concatenation of multi-labels if called recursively
				if ($cmds[$no]{performance}=~/check_multi::check_multi::(.*)/) {
					$perftmp="$cmds[$no]{name}::check_multi::$1 ";
				} elsif ($cmds[$no]{performance}=~/::check_multi::/) {
					$perftmp="$cmds[$no]{performance} ";
				} else {
					#--- do we have an explicit plugin specification? take it
					my $plugin=($cmds[$no]{pplugin} ne "") ? $cmds[$no]{pplugin} : $cmds[$no]{plugin};
					if ($cmds[$no]{performance}=~/^\s*\'([^']*)\'=(\S+)(.*)/) {
						$perftmp="\'$cmds[$no]{name}::${plugin}::$1\'=$2$3 ";
					} else {
						$cmds[$no]{performance}=~s/\s*(.*)/$1/;
						$perftmp="$cmds[$no]{name}::${plugin}::$cmds[$no]{performance} ";
					}
				}
				$cmds[$no]{performance}="";
				DEBUG4("report_perfdata before splitting: $perftmp");
				#--- preserve '::' as multi delimiter - replace all '::' with '_'
				while ($perftmp=~/\s*([^=]+)=(\S+)\s*(.*)/) {
					my $label=$1;
					my $data=$2;
					$perftmp=$3;

					my @tmparr=split(/::/,$label);
					DEBUG4("report_perfdata token before splitting: $label [0-$#tmparr]:" . join("|",@tmparr));
					if ($#tmparr > 1) {
						$cmds[$no]{performance}.=shift(@tmparr)."::".shift(@tmparr)."::";
						$cmds[$no]{performance}.=join("_",@tmparr);
					} else {
						$cmds[$no]{performance}.=$label;
					}
					$cmds[$no]{performance}.="=$data ";
					DEBUG4("report_perfdata remaining perftmp: $perftmp");
				}
				DEBUG4("report_perfdata complete after splitting: $cmds[$no]{performance}");
				print $cmds[$no]{performance};
			}
		}
	} elsif ($opt{set}{report} & $DETAIL_PERFORMANCE_CLASSIC) {
		print "\|";

		#--- one line per command, format: tag=output
		for ($no=1;$no<=$#cmds;$no++) {

			#--- suppress_perfdata set? ignore perfdata
			next if (! $cmds[$no]{process_perfdata});

			if (defined($cmds[$no]{performance})) {
				if (my $errstr=error_in_perfdata($cmds[$no]{performance})) {
					add_error("$cmds[$no]{name} perfdata discarded for $errstr");
				} else {
					print "$cmds[$no]{performance} ";
				}
			}
		}
	}
}

#---
#--- find errors in perfdata
#---
sub error_in_perfdata {
	my $perfdata=shift;
	my $label="";
	my $data="";
	my $error="";
	my $uom="";


	#---
	#--- 'label'=value[UOM];[warn];[crit];[min];[max]
	#---
	#--- loop over perfdata
	while ($perfdata) {
		DEBUG4("error_in_perfdata: parsing perfdata:$perfdata");	
		#--- label w/ \'
		if ($perfdata=~/^\s*(\'[^']*\')=([^ ]+)(.*)/) {
			$label=$1;
			$data=$2;
			$perfdata=$3;
			DEBUG4("error_in_perfdata: parsed perfdata -'label':$1 data:$2 rest:$3");	
		#--- label w/o \'
		} elsif ($perfdata=~/^\s*([^\s=']+)=([^ ]+)(.*)/) {
			$label=$1;
			$data=$2;
			$perfdata=$3;
			DEBUG4("error_in_perfdata: parsed perfdata - label:$1 data:$2 rest:$3");	
		} else {
			DEBUG2("error_in_perfdata: general parsing error - invalid perfdata");	
			return "general error in '$perfdata'";
		}
		$perfdata=~s/^\s+//; $perfdata=~s/\s+$//;

		#--- perfdata has label and data, now do detailed checks
		my ($value,$warning,$critical,$min,$max)=split(/;/,$data);
		return "$label: no value in data \'$data\'" if ($value eq "");
		if ($value=~/([-0-9.]+)([^0-9-.]{0,2})/) {
			$value=$1;
			$uom=$2;
		}

		#--- invalid perfdata with trailing ';' after max value
		if (($data=~tr/;//)>=5) {
			DEBUG2("error_in_perfdata: invalid ';' after max value $max");	
			return "error in '$data': invalid ';' after max value $max";
		} else {
			DEBUG4("error_in_perfdata: number of ';' ok in $data: " . scalar($data=~tr/;//));	
		}

		$error.= "$label: bad value \'$value\' in data \'$data\' " if ($value && $value !~/^[-0-9.]+$/);
		$error.= "$label: bad UOM \'$uom\' in data \'$data\' " if ($uom ne "" && ($uom!~/s$/ && $uom!~/%$/ && $uom!~/b$/i && $uom!~/c$/));
		$error.= "$label: bad warning \'$warning\' in data \'$data\' " if ($warning && $warning !~/^[-0-9.:]+$/);
		$error.= "$label: bad critical \'$critical\' in data \'$data\' " if ($critical && $critical !~/^[-0-9.:]+$/);
		$error.= "$label: bad min \'$min\' in data \'$data\' " if ($min && $min !~/^[-0-9.]+$/);
		$error.= "$label: bad max \'$max\' in data \'$data\' " if ($max && $max !~/^[-0-9.]+$/);
		return $error if ($error);

		#--- done: perfdata is ok
	}
	DEBUG3("error_in_perfdata: no errors found");	
	return undef;
}

#---
#--- helper routine to generate Nagios service check definitions
#---    mostly needed for 'check_multi_feeds_passive'
sub report_service_definition {
	my @tpl="";
	#--- use template for service definition
	if (! -f "$opt{set}{service_definition_template}") {
		add_error("service definition template file \'$opt{set}{service_definition_template}\' not found");
		return 1;
	} elsif (!open(DEF, $opt{set}{service_definition_template})) {
			add_error("Cannot open $opt{set}{service_definition_template}:$?");
			return 2;
	} else {
		@tpl=<DEF>;
		close DEF;
	}
	my $output="";
        for($no=1;$no<=$#cmds;$no++) {
		next if ($cmds[$no]{type} eq "eval");
		my @svc=@tpl;
		foreach my $line (@svc) {
			DEBUG4("report_service_definition: before substitution: $line");
			$line=~s/THIS/$no/g;
			$line=substitute_macros($line);
			DEBUG4("report_service_definition: after substitution: $line");
			$output.=$line;
		}
        }
	print $output;
}



sub report_send_nsca {
	# 
	# NSCA Client 2.5
	# Copyright (c) 2000-2006 Ethan Galstad (www.nagios.org)
	# Last Modified: 01-21-2006
	# License: GPL v2
	# Encryption Routines: NOT AVAILABLE
	# 
	# Usage: /usr/local/nagios/sbin/send_nsca -H <host_address> [-p port] [-to to_sec] [-d delim] [-c config_file]
	# 
	# Options:
	#  <host_address> = The IP address of the host running the NSCA daemon
	#  [port]         = The port on which the daemon is running - default is 5667
	#  [to_sec]       = Number of seconds before connection attempt times out.
	#                   (default timeout is 10 seconds)
	#  [delim]        = Delimiter to use when parsing input (defaults to a tab)
	#  [config_file]  = Name of config file to use
	# 
	# Note:
	# This utility is used to send passive check results to the NSCA daemon.  Host and
	# Service check data that is to be sent to the NSCA daemon is read from standard
	# input. Input should be provided in the following format (tab-delimited unless
	# overriden with -d command line argument, one entry per line):
	# 
	# Service Checks:
	# <host_name>[tab]<svc_description>[tab]<return_code>[tab]<plugin_output>[newline]
	# 
	# Host Checks:
	# <host_name>[tab]<return_code>[tab]<plugin_output>[newline]
	#
	my $sent=0;

	if (! -x "$opt{set}{send_nsca}") {
		add_error("report_send_nsca: $opt{set}{send_nsca} not found or not executable:$!");
		return $sent;
	}
	if (! -f "$opt{set}{send_nsca_cfg}") {
		add_error("report_send_nsca: $opt{set}{send_nsca_cfg} not found or not readable for UID $>:$!");
		return $sent;
	}
	#--- determine hostname
	my $hostname="";
	if ($ENV{MULTI_HOSTNAME}) {
		$hostname=$ENV{MULTI_HOSTNAME};
	} elsif ($ENV{MULTI_HOSTADDRESS}) {
		$hostname=$ENV{MULTI_HOSTADDRESS};
	} else {
		$hostname=`uname -n`;
	}
	chomp($hostname);
	my $nsca_cmdline=
		"$opt{set}{send_nsca} " . 
		"-H $opt{set}{send_nsca_srv} " .
		"-p $opt{set}{send_nsca_port} " .
		"-to $opt{set}{send_nsca_timeout} " .
		"-d \'$opt{set}{send_nsca_delim}\' " .
		"-c $opt{set}{send_nsca_cfg}";
	DEBUG3("report_send_nsca: cmdline is \'$nsca_cmdline\'");
	for (my $i=1; $i<=$#cmds; $i++) {

		#--- service will be suppressed if its mentioned in '-s suppress_service=<service1>,<service2>,...
		if ($opt{set}{suppress_service} && 
		    $opt{set}{suppress_service}=~/\b$cmds[$i]{name}\b/i) {
			DEBUG2("report_send_nsca: checkresult file of [ $cmds[$i]{name} ] will be suppressed");
			next;
		}
		
		#--- call send_ncsa
		if (!open(SEND_NSCA, "|$nsca_cmdline >/dev/null")) {
			add_error("report_send_nsca: error calling command line $nsca_cmdline");
			return $sent;
		}
		printf SEND_NSCA "%s;%s;%s;%s\n",
			$hostname,
			$cmds[$i]{name},
			$cmds[$i]{rc},
			$cmds[$i]{output};
		if ($?) {
			add_error("report_send_nsca: error sending data to nsca:$?");
		} else {
			$sent++;
		}
		close SEND_NSCA;
	}
	return $sent;
}

#---
#--- report child checks as check_result files
#---
sub report_checkresult_file {

	#--- use File::Temp for generation of temp file, its available in standard perl
	unless (eval "use File::Temp qw/tempfile/;1") {
		add_error("report_checkresult_file error: check_multi needs module File::Temp");
		return 0;
	} else {
		DEBUG3("report_checkresult_file: File::Temp module loaded");
	}

	# loop over child checks
	for (my $i=1; $i<=$#cmds; $i++) {

		#--- service will be suppressed if its mentioned in '-s suppress_service=<service1>,<service2>,...
		if ($opt{set}{suppress_service} && 
		    $opt{set}{suppress_service}=~/\b$cmds[$i]{name}\b/i) {
			DEBUG2("report_checkresult_file: checkresult file of [ $cmds[$i]{name} ] will be suppressed");
			next;
		}
		#--- create checkresults file
		my ($th,$tf)=File::Temp::tempfile("cXXXXXX",DIR=>"$opt{set}{checkresults_dir}");
		my $content=
		"### check_multi passive check result file $tf ###\n".
		"file_time=".int(time)."\n\n".
		"### child check result ###\n".
		"# Time: ".scalar(localtime($cmds[$i]{starttime}))."\n" .
		"host_name=".$opt{set}{HOSTNAME}."\n".
		"service_description=$cmds[$i]{name}\n".
		"check_type=1\n".
		"check_options=0\n".
		"scheduled_check=0\n".
		"reschedule_check=0\n".
		"latency=0\n".
		"start_time=".$cmds[$i]{starttime}."\n".
		"finish_time=".$cmds[$i]{endtime}."\n".
		"early_timeout=0\n".
		"exited_ok=1\n".
		"return_code=".$cmds[$i]{rc}."\n".
		"output=".$cmds[$i]{output}."\n";
		print $th $content;
		close $th;

		#--- write OK file
		if (!open(OKFILE, ">$tf.ok")) {
			 add_error("report_checkresult_file: Cannot write OK file to $tf.ok:$!");
		} else {
			DEBUG4("report_checkresult_file: $tf.ok written");
			close OKFILE;
		}
	}

}

#-------------------------------------------------------------------------------
#--- main ----------------------------------------------------------------------
#-------------------------------------------------------------------------------

#--- take care against signals
install_signal_handler(\install_signal_handler, "INT", "TERM", "QUIT", "HUP");

#--- parse command line options and STDIN
exit $UNKNOWN if (&process_input != $OK);

#--- don't run this as root ;-) 
add_error("please don't run plugins as root!") if ($> == 0);

#--- parse command file (nrpe format)
&parse_files($opt{filename});

#--- parse single command lines
&parse_lines(@{$opt{execute}});

#--- no child checks defined yet? Throw UNKNOWN
if ($#cmds<1) {
	add_error("no checks defined");
	$rc{head}=$opt{set}{no_checks_rc};
	$rc{expr}[$OK]="0==1" if ($opt{set}{no_checks_rc} != $OK);
} else {
	DEBUG4("main: running " . ($#cmds - 1) . " child checks");
}

#--- initialize timer for overall timeout
$cmds[0]{starttime}=time;
$cmds[0]{timeouttime}=$cmds[0]{starttime} + $opt{set}{TIMEOUT};

#--- loop over commands in order of config file
$no=1;
while ($no<=$#cmds) {
	
	#--- if total timeout is going to be exceeded, cancel next commands
	if (time + $opt{set}{timeout} > $cmds[0]{timeouttime}) {
		$cmds[$no]{output}="UNKNOWN - execution cancelled due to global timeout ($opt{set}{TIMEOUT}s)";
		$cmds[$no]{rc}=$UNKNOWN;
		$cmds[$no]{runtime}=0;
	} elsif ($cmds[$no]{feeded}) {
		# do nothing - this cmd has been feeded in via STDIN
	} else {
		#--- execute command
		&exec_command($no);
	}

	$no++;
}
$cmds[0]{endtime}=time;

#--- prepare output
&result_rating;

#--- report
&report_all;

#--- return rc with highest severity
exit $rc{head};
